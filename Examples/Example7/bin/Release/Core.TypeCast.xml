<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Core.TypeCast</name>
    </assembly>
    <members>
        <member name="T:Core.TypeCast.Base.Converter">
            <summary>The Converter base class, providing a simple container for conversion types, <see cref="T:Core.TypeCast.ConverterAttribute" /> and corresponding conversion functions</summary>
            <remarks>The Converter is usually invoked through <see cref="M:Core.TypeCast.ObjectExtension.CastTo``1(System.Object,``0)" /> and <see cref="M:Core.TypeCast.ObjectExtension.TryCast``2(``0,``1@,``1,System.Boolean,System.Boolean,Core.TypeCast.IConvertContext)" /></remarks>
            <seealso cref="T:Core.TypeCast.Converter`2" />
            <seealso cref="T:Core.TypeCast.ConverterCollection" />
        </member>
        <member name="F:Core.TypeCast.Base.Converter.attribute">
            <summary>
                The attribute for any arbitrary class of <see cref="P:Core.TypeCast.Base.Converter.BaseType" /> that provides conversion functionality. If no <see cref="P:Core.TypeCast.Base.Converter.Attribute" /> is present the
                value is set `null`.
            </summary>
            <remarks>Requires a <seealso cref="P:Core.TypeCast.Base.Converter.BaseType" /> to be set</remarks>
        </member>
        <member name="M:Core.TypeCast.Base.Converter.#ctor(System.Type,System.Type,System.Type,System.Type,Core.TypeCast.ConverterAttribute)">
            <summary>Initializes a new instance of the <see cref="T:Core.TypeCast.Base.Converter" /> class.</summary>
            <param name="from"> The source/from conversion <see cref="T:System.Type" /></param>
            <param name="to"> The target/to conversion <see cref="T:System.Type" /> </param>
            <param name="argument">The <seealso cref="T:System.Type" /> of the argument passed to <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault" /></param>
            <param name="baseType">The <see cref="T:System.Type" /> of any underlying converter class if one exists</param>
            <param name="attribute">The <see cref="T:Core.TypeCast.ConverterAttribute" /> of the converter-class if present.</param>
            <remarks>Only invoked by <see cref="T:Core.TypeCast.Converter`2" /></remarks>
            <seealso cref="T:Core.TypeCast.Converter`2" />
        </member>
        <member name="P:Core.TypeCast.Base.Converter.Argument">
            <summary>The <seealso cref="T:System.Type" /> of the argument passed to <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault" />
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.ArgumentStandard">
            <summary>
                Returns `true` if the Argument-<see cref="T:System.Type"/>is the default value <see cref="T:System.Object"/>. As all converters are contained in strongly typed <see cref="T:Core.TypeCast.Converter`3"/> 's 
                the argument is set to <see cref="T:System.Object"/> if unused. However explicit conversion to the <see cref="T:System.Object"/> is still possible.
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.Attribute">
            <summary>Gets or sets the <see cref="T:Core.TypeCast.ConverterAttribute" /> if the custom converter class has one defined, else it is set `null`.</summary>
            <remarks>The value is set once upon first access and is not updated thereafter, unless reset to `null`</remarks>
            <seealso cref="!:ConverterCollection.GetConverterAttributeFromIConverter(System.Reflection.TypeInfo,Core.TypeCast.ConverterAttribute,bool)" />
        </member>
        <member name="P:Core.TypeCast.Base.Converter.Base">
            <summary>Gets the reference to the Base instance of <see cref="T:System.Type"/> <see cref="P:Core.TypeCast.Base.Converter.BaseType"/>  if one exists, otherwise the value is `null`.</summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.BaseType">
            <summary>Gets the underlying <see cref="T:System.Type" /> of the custom converter class if one exists, otherwise the value is `null`.</summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.Collection">
            <summary>Gets or sets the underlying <see cref="T:Core.TypeCast.ConverterCollection" /> if the converter has been added to one, otherwise the value is `null`.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Core.TypeCast.Base.Converter.AllowDisambiguates" -->
        <member name="P:Core.TypeCast.Base.Converter.DefaultValueAnyType">
            <summary>
                Gets or sets a value indicating whether the second argument of <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault" /> is <see cref="T:System.Type" />-checked to enforce type
                quality with the return Type of the Function
            </summary>
            <seealso cref="P:Core.TypeCast.ConverterCollectionSettings.DefaultValueAnyType" />
        </member>
        <member name="P:Core.TypeCast.Base.Converter.From">
            <summary>Gets the <see cref="T:System.Type" /> of the object instance which is to be converted.</summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.Function">
            <summary>The boxed converter function of <see cref="P:System.Type.DeclaringType" /> <see cref="M:Core.TypeCast.IConverter`2.Convert(`0,`1)" />
            </summary>
            <returns>`null` if no function is set</returns>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.FunctionInfo">
            <summary>Gets an instance of <see cref="T:System.Reflection.MethodInfo"/> describing the <see cref="P:Core.TypeCast.Base.Converter.Function"/>. 
            May be null if the converter constructor was not passed a <see cref="T:System.Reflection.MethodInfo"/> instance.
            </summary>
            <returns>`null` if no function is set</returns>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.FunctionAttribute">
            <summary>Gets an instance of <see cref="T:Core.TypeCast.ConverterMethodAttribute"/> of the <see cref="P:Core.TypeCast.Base.Converter.Function"/> if it exists. 
            May also be `null` if the attribute property has not been set.
            </summary>
            <returns>`null` if no function is set</returns>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.FunctionDefault">
            <summary>
                The boxed converter function with an additional second argument value that allows passing a any arbitrary or default-value which may be returned in case of conversion
                failure or the conversion result yielding `null`. It may also be used as an essential argument for <see cref="!:ObjectExtension.ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/>
            </summary>
            <returns>`null` if no function is set</returns>
            <remarks>The actual implementation and use of the second parameter lies solely within the scope of the programmer implementing the converter logic</remarks>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.FunctionDefaultInfo">
            <summary>Gets an instance of <see cref="T:System.Reflection.MethodInfo"/> describing the <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/>. 
            May be null if the converter constructor was not passed a <see cref="T:System.Reflection.MethodInfo"/> instance.
            </summary>
            <returns>`null` if no function is set</returns>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.FunctionDefaultAttribute">
            <summary>Gets an instance of <see cref="T:Core.TypeCast.ConverterMethodAttribute"/> of the <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/> if it exists. 
            May also be `null` if the attribute property has not been set.
            </summary>
            <returns>`null` if no function is set</returns>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.HasDefaultFunction">
            <summary>Gets a value indicating whether the converter has a <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault" /> set.</summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.HasDefaultFunctionOnly">
            <summary>Gets a value indicating whether the converter has only a <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault" /> set.</summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.HasFunction">
            <summary>Gets a value indicating whether the converter has either <see cref="P:Core.TypeCast.Base.Converter.Function" /> or <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault" /> set.</summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.Standard">
            <summary>
                Gets a value indicating whether the <see cref="T:Core.TypeCast.Base.Converter" /> instance is strictly typed such that the <seealso cref="P:Core.TypeCast.Base.Converter.Argument" /> <see cref="T:System.Type" />
                is set to the <see cref="T:System.Type" /> of <see cref="P:Core.TypeCast.Base.Converter.To" />.
            </summary>
            <remarks>
                <seealso cref="T:Core.TypeCast.Converter`2" /> inherits from <seealso cref="T:Core.TypeCast.Converter`3" />. Due to the strictly-typed nature of the converter
                instances the <seealso cref="P:Core.TypeCast.Base.Converter.FunctionDefault" /> is only passes a default-value if the passed value is of the same type as <see cref="P:Core.TypeCast.Base.Converter.To" />. This property
                allows quick lookups.
            </remarks>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.NameSpace">
            <summary>
                Gets the <see cref="P:System.Type.Namespace" /> that the <see cref="T:Core.TypeCast.Base.Converter" /> instance is assigned to, with the possibility of many converters declaring
                the same namespace , that is using a one to many relationship. The handling of the <see cref="P:Core.TypeCast.Base.Converter.NameSpace" /> lies within the responsibility of the
                <see cref="T:Core.TypeCast.ConverterCollection" />
            </summary>
            <remarks>The namespace is used for grouping, filtering and on-demand loading purposes.</remarks>
            <seealso cref="P:Core.TypeCast.ConverterAttribute.LoadOnDemand" />
        </member>
        <member name="P:Core.TypeCast.Base.Converter.To">
            <summary>Gets the <see cref="T:System.Type" /> that the instance will be converted to.</summary>
        </member>
        <member name="P:Core.TypeCast.Base.Converter.UseFunctionDefaultWrapper">
            <summary>
                Gets or sets a value indicating whether to use a default-value wrapper function if a default-value was passed but no conversion function taking a
                default-value exists
            </summary>
            <seealso cref="P:Core.TypeCast.ConverterCollectionSettings.UseFunctionDefaultWrapper" />
            <seealso cref="P:Core.TypeCast.Base.Converter.FunctionDefault" />
        </member>
        <member name="P:Core.TypeCast.Base.Converter.DebuggerDisplay">
            <summary>Provides a formatted string showing the state of the Converter Types and Type information for debugging and logging</summary>
            <returns>Returns a A formatted string showing the state of the Converter Types and Type information for debugging and logging</returns>
            <example>
                **Example:** Using DebuggerDisplayAttribute in Live Debuggers. nq = no quotes, to omit the typical string quotes
                <code>
            ```cs
                [DebuggerDisplay("{DebuggerDisplay,nq}")]
                [Converter]
                public class CustomeConverter { .... }
            
            ```
            </code>
            </example>
        </member>
        <member name="M:Core.TypeCast.Base.Converter.Convert(System.Object,System.Object)">
            <summary> The converter function as part of the <see cref="T:Core.TypeCast.IConverter" /> interface support. </summary>
            <param name="value">The value to be converted.</param>
            <param name="defaultValue">The optional default value to be passed if the conversion fails or is `null`.</param>
            <returns>The converted value as a boxed <see cref="T:System.Object" />.</returns>
            <remarks>
            <remarks>The actual implementation and use of the second parameter lies solely within the scope of the programmer implementing the converter logic</remarks>
            </remarks>
        </member>
        <member name="M:Core.TypeCast.Base.Converter.ToString">
            <summary>Overrides <see cref="M:System.Object.ToString" /> to provide a string representation of the underlying conversion types</summary>
            <returns>Returns a string containing information about the conversion types <see cref="P:Core.TypeCast.Base.Converter.From" /> and <see cref="P:Core.TypeCast.Base.Converter.To" /> as well as the <see cref="P:Core.TypeCast.Base.Converter.BaseType" />
            </returns>
        </member>
        <member name="M:Core.TypeCast.Base.Converter.ToString(System.Boolean)">
            <summary>Overrides <see cref="M:System.Object.ToString" /> to provide information about the conversion types</summary>
            <param name="fullName">Whether to show the full reflected name information</param>
            <returns>Returns a string containing information about the conversion types <see cref="P:Core.TypeCast.Base.Converter.From" /> and <see cref="P:Core.TypeCast.Base.Converter.To" /> as well as the <see cref="P:Core.TypeCast.Base.Converter.BaseType" />
            </returns>
            <seealso cref="M:Core.TypeCast.Base.Converter.ToString" />
        </member>
        <member name="M:Core.TypeCast.Base.Converter.CheckConvertTypes(System.Object,System.Object)">
            <summary> Checks the types being in the correct source and target format, if not an <see cref="T:System.Exception"/> is thrown. </summary>
            <param name="value">The value to be converted.</param>
            <param name="defaultValue">The optional default value to be passed if the conversion fails or is `null`.</param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws exceptions based on mismatching types or null references</exception>
        </member>
        <member name="T:Core.TypeCast.Base.BaseClassFactoryRT">
            <summary>
            Creates instances from classes which are attributed by <see cref="T:Core.TypeCast.ConverterAttribute"/>
            </summary>
        </member>
        <member name="M:Core.TypeCast.Base.BaseClassFactoryRT.Create(System.Type)">
            <summary>
            Creates a new instance of <see cref="T:System.Type"/> <paramref name="converterClass"/>
            </summary>
            <param name="converterClass">The class which is attributed by <see cref="T:Core.TypeCast.ConverterAttribute"/></param>
            <exception cref="T:Core.TypeCast.ConverterCollectionException">An exception raised by the <see cref="M:Core.TypeCast.Base.BaseClassFactoryRT.Create(System.Type)"/> method pre-instance creation, if the <see cref="!:converterClass"/>
            was previously instanced by the <see cref="T:Core.TypeCast.ConverterCollection"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">An exception-wrapper containing an <see cref="P:System.Exception.InnerException"/> of an error which occurred during or 
            at instance creation.</exception>
        </member>
        <member name="M:Core.TypeCast.Base.BaseClassFactoryRT.Create(System.Type,Core.TypeCast.ConverterCollection)">
            <summary>
            Creates a new instance of <see cref="T:System.Type"/> <paramref name="converterClass"/>
            </summary>
            <param name="converterClass">The class which is attributed by <see cref="T:Core.TypeCast.ConverterAttribute"/></param>
            <param name="collection">A n optional <see cref="T:Core.TypeCast.ConverterCollection"/> instance passed during instance creation for Dependency Injection</param>
            <returns>Returns a new instance of <paramref name="converterClass"/> upon success, else null</returns>
            <exception cref="T:Core.TypeCast.ConverterCollectionException">An exception raised by the <see cref="M:Core.TypeCast.Base.BaseClassFactoryRT.Create(System.Type)"/> method pre-instance creation, if the <see cref="!:converterClass"/>
            was previously instanced by the <see cref="T:Core.TypeCast.ConverterCollection"/>.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">An exception-wrapper containing an <see cref="P:System.Exception.InnerException"/> of an error which occurred during or 
            at instance creation.</exception>
        </member>
        <member name="T:Core.TypeCast.Base.DependencyInjection`1">
            <summary>
            The generic class used for deriving specific dependency-injection classes, used for reflection, filtering, and strict checks at compile time.
            </summary>
            <typeparam name="TDependency">The <see cref="T:System.Type"/> of the dependency</typeparam>
            <exception cref="T:Core.TypeCast.DependencyInjectionException">
                If the <paramref name="injector" /> is `null` a <see cref="T:Core.TypeCast.DependencyInjectionException"/> is thrown
            </exception>
            <seealso cref="T:Core.TypeCast.Base.ConverterCollectionDependency"/>
        </member>
        <member name="M:Core.TypeCast.Base.DependencyInjection`1.#ctor(`0)">
            <summary>Initializes a new instance of the abstract <see cref="T:Core.TypeCast.Base.DependencyInjection`1" /> class.</summary>
            <param name="injector">
                The <see cref="!:injector" /> injection parameter which is required as an argument of the parent class constructor for dependency injection.
            </param>
            <exception cref="T:Core.TypeCast.DependencyInjectionException">
                If the <paramref name="injector" /> is `null` a <see cref="T:Core.TypeCast.DependencyInjectionException"/> is thrown
            </exception>
        </member>
        <member name="T:Core.TypeCast.Base.ConverterFactoryRT`1">
            <summary>
            Creates new instances of <see cref="T:Core.TypeCast.Converter`2"/> or <see cref="T:Core.TypeCast.Converter`3"/> dependent on the 
            number of parameters defined in <paramref name="methodInfo"/> and whether a delegate was passed.
            </summary>
            <typeparam name="TConverter">The generic type of the Converter class to instance</typeparam>
        </member>
        <member name="M:Core.TypeCast.Base.ConverterFactoryRT`1.Create(System.Reflection.MethodInfo,System.Object)">
            <summary>
                Creates a strictly typed <see cref="T:Core.TypeCast.Converter`3"/> container in case of any attribute-assigned method
                or a passed <see cref="T:System.Reflection.MethodInfo"/> with a parameter argument count of two. Otherwise a strictly typed <see cref="T:Core.TypeCast.Converter`2"/> container 
                instance is created and returned.
            </summary>
            <param name="methodInfo">A methodInfo for a converter method, crucially confining the number of function parameters between one and two. 
            Otherwise an <see cref="T:Core.TypeCast.ConverterException"/> is raised.</param>
            <param name="converterDelegate">An optional delegate of the converter method.</param>
            <returns>A new instance of a <see cref="T:Core.TypeCast.Base.Converter"/> with a parent of either <see cref="T:Core.TypeCast.Converter`3"/> or <see cref="T:Core.TypeCast.Converter`2"/>.</returns>
            <exception cref="T:Core.TypeCast.ConverterException">If the number or types of the parameters mismatch an exception is raised.</exception>
        </member>
        <member name="T:Core.TypeCast.Base.ConverterFactory`1">
            <summary>
            The abstract definition class for <see cref="T:Core.TypeCast.Base.ConverterFactory"/>
            </summary>
            <typeparam name="TInstance">The <see cref="T:System.Type"/> of the converter instances to create.</typeparam>
        </member>
        <member name="M:Core.TypeCast.Base.ConverterFactory`1.Create``2(System.Func{``0,``1})">
            <summary>
            Creates new <see cref="!:TInstance"/> instances dependent on the source <typeparamref name="TIn"/> and target <see cref="T:System.Type"/> <typeparamref name="TOut"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to convert</typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to convert</typeparam>
            <param name="method">The converter method taking only one input parameter of <see cref="T:System.Type"/> <typeparamref name="TIn"/></param>
            <remarks>Only one method may be passed during instance creation, as compatible standard converters (<see cref="P:Core.TypeCast.Base.Converter.Standard"/>) are merged automatically.</remarks>
            <returns>Returns a new instance of <see cref="!:TInstance"/> upon success</returns>
        </member>
        <member name="M:Core.TypeCast.Base.ConverterFactory`1.Create``2(System.Func{``0,``1,``1})">
            <summary>
            Creates new <see cref="!:TInstance"/> instances dependent on the source <typeparamref name="TIn"/> and target <see cref="T:System.Type"/> <typeparamref name="TOut"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to convert</typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to convert</typeparam>
            <param name="method">The converter method taking two input parameters of <see cref="T:System.Type"/> <typeparamref name="TIn"/> and <typeparamref name="TOut"/></param>
            <remarks>Only one method may be passed during instance creation, as compatible standard converters (<see cref="P:Core.TypeCast.Base.Converter.Standard"/>) are merged automatically.</remarks>
            <returns>Returns a new instance of <see cref="!:TInstance"/> upon success</returns>
        </member>
        <member name="T:Core.TypeCast.Base.ConvertContext`2">
            <summary>
            Wraps the model value for the converter in a conversion-context
            </summary>
        </member>
        <member name="M:Core.TypeCast.Base.ConvertContext`2.#ctor(System.Object)">
            <summary>
            Creates a new instance of <see cref="T:Core.TypeCast.Base.ConvertContext`2"/>
            </summary>
            <param name="modelValue">The `model` value that was passed as second parameter to the conversion function </param>
        </member>
        <member name="T:Core.TypeCast.Base.ConvertContext">
            <summary>
            Wraps the model value for the converter in a conversion-context.
            </summary>
            <remarks>On rare occasions, a contextual data structure may be required which provides meta-data about the converting-process.</remarks>
        </member>
        <member name="M:Core.TypeCast.Base.ConvertContext.#ctor(System.Object)">
            <summary>
            Creates a new instance of <see cref="T:Core.TypeCast.Base.ConvertContext"/>
            </summary>
            <param name="modelValue">The `model` value that was passed as second parameter to the conversion function </param>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.From">
            <summary>
            The source <see cref="T:System.Type"/> from which to convert to the <see cref="T:System.Type"/> of <see cref="P:Core.TypeCast.Base.ConvertContext.To"/>
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.To">
            <summary>
            The target <see cref="T:System.Type"/> to which to convert the <see cref="T:System.Type"/> of <see cref="P:Core.TypeCast.Base.ConvertContext.From"/> to
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.Argument">
            <summary>
            The argument <see cref="T:System.Type"/> of the `model` as used in <see cref="!:ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/>
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.Value">
            <summary>
            An optional default value for the given type, which must not be null, otherwise an <see cref="T:Core.TypeCast.ConverterException" /> may be thrown.
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.Converter">
            <summary>
            The <see cref="P:Core.TypeCast.Base.ConvertContext.Converter"/> instance for the corresponding types <typeparamref name="TIn"/> and <typeparamref name="TOut"/>
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.Caller">
            <summary>
            The caller method name which is automatically filled-in via the <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>, and used for context information.
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.Nullable">
            <summary>
            Whether the original <paramref name="From"/> <see cref="T:System.Type"/> was nullable
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.ThrowExceptions">
            <summary>
            Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.Method">
            <summary>
            The conversion method that was invoked
            </summary>
        </member>
        <member name="P:Core.TypeCast.Base.ConvertContext.MethodInfo">
            <summary>
            The <see cref="P:Core.TypeCast.Base.ConvertContext.MethodInfo"/> instance of the <see cref="P:Core.TypeCast.Base.ConvertContext.Method"/>
            </summary>
        </member>
        <member name="T:Core.TypeCast.Base.Factory`3">
            <summary>
            The abstract generic factory for creating arbitrary instances requiring up to two arguments. Use a container type such as <see cref="T:System.Tuple"/> or <see cref="!:struct"/> 
            as second parameter type <typeparamref name="TIn2"/> if more parameters are required.
            </summary>
            <typeparam name="TInstance">The <see cref="T:System.Type"/> of the instances to create and return by the factory method <see cref="M:Core.TypeCast.Base.Factory`3.Create(`1)"/>
            and <see cref="M:Core.TypeCast.Base.Factory`3.Create(`1,`2)"/>.</typeparam>
            <typeparam name="TIn1">The parameter type used for defining the instance creation process in the factory method <see cref="M:Core.TypeCast.Base.Factory`3.Create(`1)"/></typeparam>
            <typeparam name="TIn2">The 2. parameter type used for defining the instance creation process in the factory method <see cref="M:Core.TypeCast.Base.Factory`3.Create(`1)"/> 
            and <see cref="M:Core.TypeCast.Base.Factory`3.Create(`1,`2)"/></typeparam>
        </member>
        <member name="P:Core.TypeCast.Base.Factory`3.Name">
            <summary>
            Gets a string representation of the Base-Factory using <see cref="M:Core.TypeCast.Base.Factory`3.ToString"/>
            </summary>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.GetInterfaces">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the interfaces supported by the factory instance.
            </summary>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.GetParameters">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/> of the generic parameters that constructed the base-factory instance.
            </summary>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.Create(`1)">
            <summary>
            Abstract method for creating instances of <typeparamref name="TInstance"/> defined only through <paramref name="parameter"/>
            </summary>
            <param name="parameter">The parameter to define the instance creation process</param>
            <returns>an instance of <see cref="T:System.Type"/> <typeparamref name="TInstance"/></returns>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.Create(`1,`2)">
            <summary>
            Abstract method for creating instances of <typeparamref name="TInstance"/> defined only through <paramref name="parameter"/> 
            and <paramref name="parameter2"/> 
            </summary>
            <param name="parameter">The parameter to define the instance creation process</param>
            <param name="parameter2">The 2. parameter to define the instance creation process</param>
            <returns>an instance of <see cref="T:System.Type"/> <typeparamref name="TInstance"/></returns>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.Instantiate(System.Type,System.Object[])">
            <summary>
            Internal method for object instantiation by a passed type <paramref name="type"/>
            </summary>
            <param name="type">the type of the <see cref="!:class"/> or <see cref="!:struct"/> which to instance</param>
            <param name="parameters">the parameters passed to the constructor of the <see cref="!:class"/> or <see cref="!:struct"/></param>
            <returns>Returns an instance object of type <typeparamref name="TOut"/> or `null`</returns>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.TryInstantiate(System.Type,System.Object@,System.Object[])">
            <summary>
            Internal method for object instantiation following the "Try" convention of returning a bool `true` upon success and passing the result with `out`
            </summary>
            <param name="type">The type of the <see cref="!:class"/> or <see cref="!:struct"/> which to instance</param>
            <param name="parameters">The parameters passed to the constructor of the <see cref="!:class"/> or <see cref="!:struct"/></param>
            <param name="instance">The assigned instance reference upon instancing of type <typeparamref name="TOut"/> or `null` upon failure</param>
            <returns>Returns <see cref="T:System.Boolean"/> `true` upon success or `false` upon failure and assigning `null` to <paramref name="instance"/></returns>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.Instantiate``1(System.Type,System.Type[],System.Object[])">
            <summary>
            Internal method object instantiation of a generic type , with the generic-parameters passed as the second argument
            </summary>
            <typeparam name="TOut">The type of the instance to pass out</typeparam>
            <param name="type">The type of the <see cref="!:class"/> or <see cref="!:struct"/> which to instance</param>
            <param name="parameters">the generic types that comprise the generic type</param>
            <param name="args">The parameters passed to the constructor of the <see cref="!:class"/> or <see cref="!:struct"/></param>
            <returns>Returns an instance object of type <typeparamref name="TOut"/> or `null`</returns>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.Instantiate``1(System.Type,System.Object[])">
            <summary>
            Creates an instance of the type designated by the specified generic type parameter
            </summary>
            <param name="type">The type of the <see cref="!:class"/> or <see cref="!:struct"/> which to instance</param>
            <param name="args">the parameters passed to the constructor of the <see cref="!:class"/> or <see cref="!:struct"/></param>
            <returns>A reference to the newly created object.</returns>
            <exception cref="!:System.MissingMethodException">NoteIn the .NET for Windows Store apps or the Portable Class Library, catch the
            base class exception, System.MissingMemberException, instead. The type that specified for T does not have a parameterless constructor.</exception>
            <remarks>Centralize all runtime calls to <code>`Activator.Create(...)`</code> and <code>constructor.Invoke(...)`</code> </remarks>
        </member>
        <member name="M:Core.TypeCast.Base.Factory`3.ToString">
            <summary>
            Returns a string representation of the Factory type.
            </summary>
        </member>
        <member name="T:Core.TypeCast.Base.ConverterFactory">
            <summary>
            Creates new instances of <see cref="T:Core.TypeCast.Converter`2"/> dependent on the source <typeparamref name="TIn"/> and target <see cref="T:System.Type"/> <typeparamref name="TOut"/>
            </summary>
        </member>
        <member name="M:Core.TypeCast.Base.ConverterFactory.Create``2(System.Func{``0,``1})">
            <summary>
            Creates new <see cref="T:Core.TypeCast.Converter`2"/> instances dependent  on the source <typeparamref name="TIn"/> and target <see cref="T:System.Type"/> <typeparamref name="TOut"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="method">The converter method taking only one input parameter of <see cref="T:System.Type"/> <typeparamref name="TIn"/></param>
            <remarks>Only one method may be passed during instance creation, as compatible standard converters (<see cref="P:Core.TypeCast.Base.Converter.Standard"/>) are merged automatically.</remarks>
            <returns>Returns a new instance of <see cref="T:Core.TypeCast.Converter`2"/> upon success</returns>
        </member>
        <member name="M:Core.TypeCast.Base.ConverterFactory.Create``2(System.Func{``0,``1,``1})">
            <summary>
            Creates new <see cref="T:Core.TypeCast.Converter`3"/> instances dependent on the source <typeparamref name="TIn"/> and <typeparamref name="TOut"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="method">The converter method taking two input parameters of <see cref="T:System.Type"/> <typeparamref name="TIn"/> and <typeparamref name="TOut"/></param>
            <remarks>Only one method may be passed during instance creation, as compatible standard converters (<see cref="P:Core.TypeCast.Base.Converter.Standard"/>) are merged automatically.</remarks>
            <returns>Returns a new instance of <see cref="T:Core.TypeCast.Converter`3"/> upon success</returns>
        </member>
        <member name="T:Core.TypeCast.Base.ConverterCollectionDependency">
            <summary>The converter dependency provides loose implementation of Converters, merely constricting the constructor to be passed an
                <see cref="T:Core.TypeCast.IConverterCollection" /> for Dependency Injection. It is not required due to Constructor auto-discovery provided by
                <see cref="M:Core.Extensions.TypeInfoExtension.IsDependencyInjectable(System.Reflection.TypeInfo,System.Type)" />
                yet provides strict typing at compile time and a slight speedup</summary>
            <remarks><see cref="T:Core.TypeCast.Base.ConverterCollectionDependency" /> only serves as a constructor implementation contract</remarks>
            <example>
                **Example:** Add DateTime converters loaded upon first access, through strict DependencyInjection
                <code>
            ```cs
                [Converter(loadOnDemand: true, nameSpace: nameof(System), dependencyInjection: true)]
                public class ConverterDateTimeDefaults : ConverterCollectionDependency
                {
                    public ConverterDateTimeDefaults(IConverterCollection collection) : base(collection)
                    {
                        this.AddDateTimeConverter(collection: collection);
                    }
                    ...
                }
            ```
            </code>
            </example>
        </member>
        <member name="M:Core.TypeCast.Base.ConverterCollectionDependency.#ctor(Core.TypeCast.IConverterCollection)">
            <summary>Initializes a new instance of the <see cref="T:Core.TypeCast.Base.ConverterCollectionDependency" /> class.</summary>
            <param name="collection">
                The <see cref="T:Core.TypeCast.IConverterCollection" /> collection which is required as an argument of the parent class constructor for custom
                dependency injection.
            </param>
            <exception cref="T:Core.TypeCast.DependencyInjectionException">
                If the <paramref name="injector" /> is `null` a <see cref="T:Core.TypeCast.DependencyInjectionException"/> is thrown
            </exception>
        </member>
        <member name="T:Core.TypeCast.Base.ConverterCollectionDependency`2">
            <summary>The converter dependency for specific implementation of Converters, implementing the logic for adding the converter to the collection</summary>
            <typeparam name="TIn">The source / from <see cref="T:System.Type" />from which to convert</typeparam>
            <typeparam name="TOut">The target / to <see cref="T:System.Type" /> to which to converter</typeparam>
            <remarks>
                The <see cref="T:Core.TypeCast.Base.ConverterCollectionDependency`2" /> necessitates overriding <see cref="M:Core.TypeCast.Base.ConverterCollectionDependency`2.Convert(`0,`1)" />:
                <code>
             ```cs
                public override TOut Convert(...) { 
                    ... 
                }
            ``` 
            </code>
            </remarks>
        </member>
        <member name="M:Core.TypeCast.Base.ConverterCollectionDependency`2.#ctor(Core.TypeCast.IConverterCollection)">
            <summary>Initializes a new instance of the <see cref="T:Core.TypeCast.Base.ConverterCollectionDependency`2" /> class.</summary>
            <param name="collection">
                The <see cref="T:Core.TypeCast.IConverterCollection" /> collection which is required as an argument of the parent class constructor for custom
                dependency injection.
            </param>
            <exception cref="T:Core.TypeCast.ConverterException">
                If the <paramref name="collection" /> is null an exception of cause <seealso cref="F:Core.TypeCast.ConverterCollectionCause.CollectionIsNull" /> is
                thrown
            </exception>
            <remarks>
                Unlike <see cref="T:Core.TypeCast.Base.ConverterCollectionDependency" />, the generic class <see cref="T:Core.TypeCast.Base.ConverterCollectionDependency`2" /> provides a
                constructor-injection contract and logic to add <see cref="M:Core.TypeCast.Base.ConverterCollectionDependency`2.Convert(`0,`1)"/> to the <paramref name="collection" />
            </remarks>
        </member>
        <member name="M:Core.TypeCast.Base.ConverterCollectionDependency`2.Convert(`0,`1)">
            <summary> The converter function that needs to be overwritten as part of the <see cref="T:Core.TypeCast.IConverter" /> interface support. </summary>
            <param name="value">The value of <see cref="T:System.Type" /> <see cref="!:TIn" /> to be converted.</param>
            <param name="defaultValue">The optional default value of <see cref="T:System.Type" /> <see cref="!:TOut" />to be passed if the conversion fails or is `null`.</param>
            <returns>The value converted to <see cref="T:System.Type" /> of <see cref="!:TOut" /> </returns>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of <see cref="F:Core.TypeCast.ConverterCause.ConverterNotImplemented" /> if the parent class does not implement
                <code>`public override TOut `</code> <see cref="M:Core.TypeCast.Base.ConverterCollectionDependency`2.Convert(`0,`1)" />
            </exception>
        </member>
        <member name="T:Core.TypeCast.ConverterCollection">
            <summary>
            The thread-safe, static collection of <see cref="T:Core.TypeCast.Base.Converter"/> items, using <see cref="N:Core.Singleton"/> and supporting <see cref="T:Core.Singleton.ISingleton"/>
            </summary>
            <remarks> See https://github.com/lsauer/csharp-singleton for more information.</remarks>
            <remarks> Building the project requires the Singleton-library: https://www.nuget.org/packages/CSharp.Portable-Singleton/ </remarks>
            <remarks>If <see cref="P:Core.Singleton.SingletonAttribute.CreateInternal"/> is set to `false`, <see cref="T:Core.TypeCast.ConverterCollection"/> must explicitly be instantiated using 
            `new ConverterCollection(...)` and  not use <see cref="!:ConverterCollection.CurrentInstance"/> before instantiation. 
            If <see cref="P:Core.Singleton.SingletonAttribute.CreateInternal"/> is set to `true`, lazy-instantiation of the singleton is possible at any time, 
            after the program's assembly entry point is reached.</remarks>
            <summary>
            The thread-safe, static collection of <see cref="T:Core.TypeCast.Base.Converter"/> items, using <see cref="N:Core.Singleton"/> and supporting <see cref="T:Core.Singleton.ISingleton"/>
            </summary>
            <remarks> See https://github.com/lsauer/csharp-singleton for more information.</remarks>
            <remarks> Building the project requires the Singleton-library: https://www.nuget.org/packages/CSharp.Portable-Singleton/ </remarks>
            <remarks>If <see cref="P:Core.Singleton.SingletonAttribute.CreateInternal"/> is set to `false`, <see cref="T:Core.TypeCast.ConverterCollection"/> must explicitly be instantiated using 
            `new ConverterCollection(...)` and  not use <see cref="!:ConverterCollection.CurrentInstance"/> before instantiation. 
            If <see cref="P:Core.Singleton.SingletonAttribute.CreateInternal"/> is set to `true`, lazy-instantiation of the singleton is possible at any time, 
            after the program's assembly entry point is reached.</remarks>
        </member>
        <member name="T:Core.TypeCast.ConverterCollection.AddBuilder`1">
            <summary>
            Allows to perform a deferred adding operation of multiple adds using a common Base-Class <see cref="T:System.Type"/> argument, 
            common <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> as well as a mutual <see cref="T:System.Threading.CancellationToken"/> for the added group of converters.
            The operation is applied upon invoking <see cref="M:Core.TypeCast.ConverterCollection.AddBuilder`1.End"/>, and can be explicitly canceled by invoking <see cref="M:Core.TypeCast.ConverterCollection.AddBuilder`1.Cancel"/>
            </summary>
            <typeparam name="TBase">The declaring, attributed <see cref="T:System.Type"/> of the converter-functions to add as a group.</typeparam>
        </member>
        <member name="F:Core.TypeCast.ConverterCollection.AddBuilder`1.baseClass">
            <summary>
            A reference to the <see cref="T:Core.TypeCast.ConverterCollection"/> instance
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollection.AddBuilder`1.cancellationToken">
            <summary>
            An optional reference to the mutual <see cref="T:System.Threading.CancellationToken"/>
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollection.AddBuilder`1.actions">
            <summary>
            The list of deferred actions to Invoke upon calling <see cref="M:Core.TypeCast.ConverterCollection.AddBuilder`1.End"/>
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollection.AddBuilder`1.settings">
            <summary>
            A reference to an optional <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> instance to be applied only for the group of converter-functions
            </summary>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddBuilder`1.#ctor(Core.TypeCast.ConverterCollection,Core.TypeCast.ConverterCollectionSettings,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of <see cref="T:Core.TypeCast.ConverterCollection.AddBuilder`1"/> for grouped-adding of converter-functions with default arguments defined 
            in the constructor
            </summary>
            <param name="converterCollection">A reference to the <see cref="T:Core.TypeCast.ConverterCollection"/> instance</param>
            <param name="settings">A reference to an optional <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> instance to be applied only for the 
            group of converter-functions</param>
            <param name="cancellationToken">An optional value-instance to the mutual <see cref="T:System.Threading.CancellationToken"/></param>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddBuilder`1.#ctor(Core.TypeCast.ConverterCollection,Core.TypeCast.ConverterCollectionSettings,System.Threading.CancellationToken@)">
            <summary>
            Creates a new instance of <see cref="T:Core.TypeCast.ConverterCollection.AddBuilder`1"/> for grouped-adding of converter-functions with mutual arguments defined 
            in the constructor
            </summary>
            <param name="converterCollection">A reference to the <see cref="T:Core.TypeCast.ConverterCollection"/> instance</param>
            <param name="settings">A reference to an optional <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> instance to be applied only for the 
            group of converter-functions</param>
            <param name="cancellationToken">An optional reference to the mutual <see cref="T:System.Threading.CancellationToken"/></param>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddBuilder`1.Add``2(System.Func{``0,``1})">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="converterAction">A function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a (nested-class) instance of <see cref="T:Core.TypeCast.ConverterCollection.AddBuilder`1"/> with strongly-typed generic methods for deferred grouped-adding.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddBuilder`1.Add``2(System.Func{``0,``1,``1})">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="converterActionDefault">A function delegate <see cref="T:System.Func`3"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a (nested-class) instance of <see cref="T:Core.TypeCast.ConverterCollection.AddBuilder`1"/> with strongly-typed generic methods for deferred grouped-adding.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddBuilder`1.Cancel">
            <summary>
            Dummy function to explicitly end the current chained builder operation without applying any deferred calls and clear any resources
            </summary>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddBuilder`1.End">
            <summary>
            End the deferred adding operation by invocation the deferred list of <see cref="F:Core.TypeCast.ConverterCollection.AddBuilder`1.actions"/>
            </summary>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Settings">
            <summary>
            The settings for the <see cref="T:Core.TypeCast.ConverterCollection"/>.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollection.loadOnDemandConverters">
            <summary>
            A list of <see cref="T:Core.TypeCast.Base.Converter"/> base-classes which have not yet been instantiated and added to <see cref="P:Core.TypeCast.ConverterCollection.Items"/>. 
            Upon first look-up they will be instantiated and removed from the list.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollection.count">
            <summary>Gets the count for <see cref="P:Core.TypeCast.ConverterCollection.Count"/>.</summary>
            <seealso cref="M:Core.Singleton.Singleton`1.OnPropertyChanged(System.Object,System.String)"/>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterCollection"/> class with default-parameters.
            <para>Instantiation with `new ConverterCollection(...)` must only be once and before any functions 
            that require <see cref="P:Core.Singleton.Singleton`1.CurrentInstance"/> </para>
            </summary>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterCollection"/> class with default-parameters.
            <para>Instantiation with `new ConverterCollection(...)` must only be once and before any functions 
            that require <see cref="P:Core.Singleton.Singleton`1.CurrentInstance"/> </para>
            </summary>
            <param name="application">The <see cref="P:System.Reflection.TypeInfo.BaseType"/> type which serves as the assembly entry point of the application e.g. `Program`</param>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.#ctor(System.Type,System.Type,System.Globalization.NumberFormatInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterCollection"/> class with default-parameters.
            <para>Instantiation with `new ConverterCollection(...)` must only be once and before any functions 
            that require <see cref="P:Core.Singleton.Singleton`1.CurrentInstance"/> </para>
            </summary>
            <param name="application">The <see cref="P:System.Reflection.TypeInfo.BaseType"/> type which serves as the assembly entry point of the application e.g. `Program`</param>
            <param name="converterClass">The type of a converter class to look for converters and load into the collection</param>
            <param name="numberFormatDefault">An optional <see cref="T:System.Globalization.NumberFormatInfo"/> to provide to any added converters for formatting.</param>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.#ctor(System.Reflection.Assembly,System.Globalization.NumberFormatInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterCollection"/> class with default-parameters.
            <para>Instantiation with `new ConverterCollection(...)` must only be once and before any functions 
            that require <see cref="P:Core.Singleton.Singleton`1.CurrentInstance"/> </para>
            </summary>
            <param name="assembly">An assembly to look for <see cref="T:Core.TypeCast.ConverterAttribute"/> to discover and load converters into the collection</param>
            <param name="numberFormatDefault">An optional <see cref="T:System.Globalization.NumberFormatInfo"/> to provide to any added converters for formatting.</param>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.#ctor(System.Type,System.Type[])">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterCollection"/> class with default-parameters.
            </summary>
            <param name="application">The <see cref="P:System.Reflection.TypeInfo.BaseType"/> type which serves as the assembly entry point of the application e.g. `Program`</param>
            <param name="converterClass">The type of a converter class to look for converters and load into the collection  <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.#ctor(System.Type,System.Globalization.NumberFormatInfo,System.Type[])">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterCollection"/> class with default-parameters.
            </summary>
            <example> **Example:** Initialize a new ConverterCollection with several custom parameters, before any invocation of a ConverterCollection instance
            <code>
            ```cs
                var cc = new ConverterCollection(typeof(Program), typeof(CustomConverters), typeof(DNA))
                {
                    AutoReset = true,
                    Settings = new ConverterCollectionSettings()
                    {
                        ConverterDefaultWrapperOrException = true
                    }
               };
            ```
            </code>
            </example>
            <param name="application">The <see cref="P:System.Reflection.TypeInfo.BaseType"/> type which serves as the assembly entry point of the application e.g. `Program`</param>
            <param name="numberFormatDefault">An optional <see cref="T:System.Globalization.NumberFormatInfo"/> to provide to any added converters for formatting.</param>
            <param name="converterClass">The types of a converter classes to encapsulate in <see cref="T:Core.TypeCast.Base.Converter"/> instances and add into the collection <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Factory">
            <summary>
            Reference to the <see cref="T:Core.TypeCast.Base.ConverterFactory"/> which facilitates the instantiation of any <see cref="T:Core.TypeCast.Base.Converter"/> 
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.FactoryBaseClass">
            <summary>
            Reference to the runtime-creation <see cref="T:Core.TypeCast.Base.BaseClassFactoryRT"/> which facilitates the instantiation of any <see cref="!:class"/> 
            which declares a converter function and has a <see cref="T:Core.TypeCast.ConverterAttribute"/>
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.ApplicationNameSpace">
            <summary>
            Stores the namespace of the application namespace. May be set during auto-initialization loading
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.ConstructorAddedClasses">
            <summary>
            Stores a list of classes that were passed into the constructor as a <see cref="!:params"/> list of types and have been added to <see cref="P:Core.TypeCast.ConverterCollection.Items"/>
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.AssemblyInitialized">
            <summary>
            Stores a list of assemblies which have been scanned for attributes and added to <see cref="P:Core.TypeCast.ConverterCollection.Items"/>
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.ConverterClassInitialized">
            <summary>
            Stores a list of the types of <see cref="T:Core.TypeCast.Base.Converter"/> function declaring-classes which have been instantiated and added to <see cref="P:Core.TypeCast.ConverterCollection.Items"/>
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Count">
            <summary>Gets the count of singletons in the list.</summary>
            <example>
            ```
            var singletonManager = new SingletonManager(new[]{typeof(ParentOfAClass), typeof(IndispensibleClass)});
            
            singletonManager.PropertyChanged += (singleton, arg) => {
                if(singletonManager.Count &lt; singletonManager.Pool.Count() ){
                    Console.WriteLine("A Singleton was added to the Manager");
                }else{
                    Console.WriteLine("A Singleton was removed from the Manager");
                }
            }
            ```
            </example>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Items">
            <summary>
            The <see cref="T:System.Collections.Concurrent.BlockingCollection`1"/> class provides a thread-safe collection with full support of the Producer-Consumer pattern, 
            to store a collection of <see cref="T:Core.TypeCast.Base.Converter"/> instances.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.IsAddingCompleted">
            <summary>
            Marks the <see cref="T:System.Collections.Concurrent.BlockingCollection`1"/> instances as not accepting any more additions.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Collections.Concurrent.BlockingCollection`1"/> has been disposed.</exception>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.ElementType">
            <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable"/> is executed.
            </summary>
            <returns>A <see cref="T:System.Type"/> that represents the type of the element(s) that are returned  when the expression tree associated with this object is executed.</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Expression">
            <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable"/>.
            </summary>
            <returns>The <see cref="T:System.Linq.Expressions.Expression"/> that is associated with this instance of <see cref="T:System.Linq.IQueryable"/>.</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Provider">
            <summary>
            Gets the query provider that is associated with this data source.
            </summary>
            <returns> The <see cref="T:System.Linq.IQueryProvider"/> that is associated with this data source.</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Item(System.Int32)">
            <summary>
            Gets the value for a given <paramref name="index"/> using <see cref="N:System.Linq"/>
            </summary>
            <param name="index">The integer index of the elements starting at zero.</param>
            <returns>A single Converter instance if a <see cref="T:System.Type"/> match was found was found, else `null`.</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Item(System.Type,System.Type)">
            <summary>
            Gets a <see cref="T:Core.TypeCast.Base.Converter"/> for a given Key by invoking <see cref="!:Get(TypeInfo, TypeInfo)"/>. If none is found, `null` is returned.
            </summary>
            <param name="typeFrom">The source <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <param name="typeTo">The target <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <returns>A single Converter instance if a <see cref="T:System.Type"/> match was found was found, else `null`.</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Item(System.Reflection.TypeInfo,System.Reflection.TypeInfo)">
            <summary>
            Gets a <see cref="T:Core.TypeCast.Base.Converter"/> for a given Key by invoking <see cref="!:Get(TypeInfo, TypeInfo)"/>. If none is found, `null` is returned.
            </summary>
            <param name="typeFrom">The source <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <param name="typeTo">The target <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <returns>A single Converter instance if a <see cref="T:System.Type"/> match was found was found, else `null`.</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterCollection.Item(System.Reflection.TypeInfo)">
            <summary>
            Looks up all converters that match the source-type argument <paramref name="typeFrom"/> and returns an <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="typeFrom">The source <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <returns>A IEnumerable of Converter instances if a <see cref="T:System.Type"/> match was found was found, else `null`.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddStart``1(Core.TypeCast.ConverterCollectionSettings,System.Threading.CancellationToken)">
            <summary>
            Allows to perform a deferred adding operation of multiple adds using a common Base-Class <see cref="T:System.Type"/> argument, 
            common <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> as well as a mutual <see cref="T:System.Threading.CancellationToken"/> for the added group of converters.
            The operation is applied upon invoking <see cref="!:End"/>, and can be explicitly canceled by invoking <see cref="!:Cancel"/>
            </summary>
            <typeparam name="TBase">The declaring <see cref="T:System.Type"/> of the converter-functions to add as a group.</typeparam>
            <param name="settings">Optional common <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> to be applied for the added group of converter-functions</param>
            <param name="cancellationToken">Optional mutual <see cref="T:System.Threading.CancellationToken"/> to be used for the grouped-adding of converter-functions</param>
            <returns>Returns a (nested-class) instance of <see cref="T:Core.TypeCast.ConverterCollection.AddBuilder`1"/> with strongly-typed generic methods for deferred grouped-adding.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddStart``1(Core.TypeCast.ConverterCollectionSettings,System.Threading.CancellationToken@)">
            <summary>
            Allows to perform a deferred adding operation of multiple adds using a common Base-Class <see cref="T:System.Type"/> argument, 
            common <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> as well as a mutual <see cref="T:System.Threading.CancellationToken"/> for the added group of converters.
            The operation is applied upon invoking <see cref="!:End"/>, and can be explicitly canceled by invoking <see cref="!:Cancel"/>
            </summary>
            <typeparam name="TBase">The declaring <see cref="T:System.Type"/> of the converter-functions to add as a group.</typeparam>
            <param name="settings">Common <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> to be applied for the added group of converter-functions</param>
            <param name="cancellationToken">Mutual <see cref="T:System.Threading.CancellationToken"/> to be used for the grouped-adding of converter-functions</param>
            <returns>Returns a (nested-class) instance of <see cref="T:Core.TypeCast.ConverterCollection.AddBuilder`1"/> with strongly-typed generic methods for deferred grouped-adding.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Add``2(System.Func{``0,``1},System.Type,System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <param name="converterAction">A function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Add``2(System.Func{``0,``1},System.Func{``1,``0},System.Type,System.Threading.CancellationToken)">
            <summary>
            Creates and adds a pair of <see cref="T:Core.TypeCast.Base.Converter"/> instances to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>, 
            which together form an _Inter-converter_, for mutual conversion between two types in either conversion direction.
            </summary>
            <param name="converterActionForward">A source-to-target <see cref="T:System.Type"/> converting function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="converterActionBackward">A target-to-source <see cref="T:System.Type"/> converting function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Add``3(System.Func{``0,``1},System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TBase">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class</typeparam>
            <param name="converterAction">A function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Add``3(System.Func{``0,``1,``1},System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="converterActionDefault">A function delegate <see cref="T:System.Func`3"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Add``4(System.Func{``0,``1,``2},System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <param name="converterActionAny">A function delegate <see cref="T:System.Func`3"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TArg">The Argument <see cref="T:System.Type"/> for generic converters using see <see cref="!:ObjectExtension.ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/>.</typeparam>
            <typeparam name="TBase">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</typeparam>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ConverterCollection.Add``3(System.Func{``0,``1,``2},System.Type,System.Threading.CancellationToken)" -->
        <member name="M:Core.TypeCast.ConverterCollection.Add``1(System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <param name="converterDelegate">An optional function delegate to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Add(System.Object,System.Type,System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <param name="converterDelegate">An optional function delegate to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <example> **Example:** Add a converter to the ConverterCollection `cc`, to converter `Nullable&lt;int>` to float 
            <code>```cs
                    var cc = new ConverterCollection(typeof(Program));
                    // Converter: [Nullable&lt;int>] --> [float]
                    cc.Add((int? a) =>
                    {
                        return (float)(a ?? 0);
                    });
            ```</code>
            </example>
            <remarks> Any lambda function or strictly declared function can be added as <paramref name="converterDelegate"/>. For more information visit the MSDN recommendations on 
            lambda expressions: https://msdn.microsoft.com/en-us/library/bb397687.aspx</remarks>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Add(System.Reflection.MethodInfo,System.Object,System.Type,System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Reflection.MethodInfo"/> instance
            </summary>
            <param name="methodInfo">A <see cref="T:System.Reflection.MethodInfo"/> instance describing a method to create a delegate from and add to the converter</param>
            <param name="converterDelegate">An optional function delegate to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</param>
            <param name="baseInstance">An optional base-class instance containing a method which is added to the converter and seves as `this` reference during invocation.</param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception if adding failed</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Add(Core.TypeCast.Base.Converter,System.Type,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/>
            </summary>
            <param name="converter">The <see cref="T:Core.TypeCast.Base.Converter"/> instance to add to the <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</param>
            <param name="allowDisambiguates">Optional <see cref="T:System.Boolean"/> value to indicate whether to allow multiple converters with the 
            same return and parameter <see cref="T:System.Type"/>s in the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/>. Only set to `true` for transform functions.</param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterCollectionException">Throws an exception if adding failed</exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.CanConvertFrom(System.Type)">
            <summary>
            Returns <see cref="T:System.Boolean"/>  `true` if the <see cref="T:Core.TypeCast.ConverterCollection"/> supports conversion for a given Type <paramref name="typeFrom"/>, else `false`.
            </summary>
            <param name="typeFrom">The source <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <remarks>The function is a wrapper for <see cref="M:Core.TypeCast.ConverterCollectionFilters.WithFrom(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo)"/>.</remarks>
            <returns>`true` if the source <see cref="T:System.Type"/> is supported as source type by any converter in the <see cref="T:Core.TypeCast.ConverterCollection"/>, else `false`</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.CanConvertFrom``1">
            <summary>
            Returns <see cref="T:System.Boolean"/>  `true` if the <see cref="T:Core.TypeCast.ConverterCollection"/> supports conversion for a given Type <paramref name="typeFrom"/>, else `false`.
            </summary>
            <typeparam name="TIn">The source <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></typeparam>
            <remarks>The function is a wrapper for <see cref="M:Core.TypeCast.ConverterCollectionFilters.WithFrom(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo)"/>.</remarks>
            <returns>`true` if the source <see cref="T:System.Type"/> is supported as source type by any converter in the <see cref="T:Core.TypeCast.ConverterCollection"/>, else `false`</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.CanConvertTo(System.Type)">
            <summary>
            Returns <see cref="T:System.Boolean"/>  `true` if the <see cref="T:Core.TypeCast.ConverterCollection"/> supports conversion for a given Type <paramref name="typeTo"/>, else `false`.
            </summary>
            <param name="typeTo">The target <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <remarks>The function is a wrapper for <see cref="M:Core.TypeCast.ConverterCollectionFilters.WithTo(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo)"/>.</remarks>
            <returns>`true` if the target <see cref="T:System.Type"/> is supported as source type by any converter in the <see cref="T:Core.TypeCast.ConverterCollection"/>, else `false`</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.CanConvertTo``1">
            <summary>
            Returns <see cref="T:System.Boolean"/>  `true` if the <see cref="T:Core.TypeCast.ConverterCollection"/> supports conversion for a given Type <paramref name="typeTo"/>, else `false`.
            </summary>
            <typeparam name="TIn">The target <see cref="T:System.Type"/> to look up in <see cref="P:Core.TypeCast.ConverterCollection.Items"/></typeparam>
            <remarks>The function is a wrapper for <see cref="M:Core.TypeCast.ConverterCollectionFilters.WithTo(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo)"/>.</remarks>
            <returns>`true` if the target <see cref="T:System.Type"/> is supported as source type by any converter in the <see cref="T:Core.TypeCast.ConverterCollection"/>, else `false`</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.ConverterAttributeFromIConverter(System.Reflection.TypeInfo,Core.TypeCast.ConverterAttribute,System.Boolean)">
            <summary>
            Adds or updates an attribute for a <see cref="T:Core.TypeCast.Base.Converter"/> if it exists, dependent only on the source and target conversion types
            </summary>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class <see cref="T:System.Type"/> if one exists</param>
            <param name="attribute">The <see cref="T:Core.TypeCast.ConverterAttribute"/> of the converter-class that is to be updated</param>
            <param name="update">Whether to update an existing <see cref="P:Core.TypeCast.Base.Converter.Attribute"/></param>
            <returns>Returns the updated <paramref name="attribute"/>, if <paramref name="update"/> was set to `true`</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.LoadOnDemandConverter(System.Type)">
            <summary>
            Tries to lookup the namespace obtained from <paramref name="typeTo"/> in <see cref="F:Core.TypeCast.ConverterCollection.loadOnDemandConverters"/> and add the converters.
            If successful the number of Added Converters are returned, and the NameSpace is removed from the list of <see cref="F:Core.TypeCast.ConverterCollection.loadOnDemandConverters"/>.
            </summary>
            <param name="typeTo"> The converter target <see cref="T:System.Type"/> to obtain the namespace from.</param>
            <remarks>Any compatible <see cref="P:Core.TypeCast.Base.Converter.Standard"/> converters will have merged after loading, as such  the returned number of loaded 
            converters does not have a direct relationship to the <see cref="P:Core.TypeCast.ConverterCollection.Count"/>
            </remarks>
            <returns>Returns <see cref="T:System.Boolean"/> an integer number > `0` if the Converters of the namespace from <paramref name="typeTo"/> were successfully added, otherwise returns `0`</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AutoInitialize">
            <summary>
            Checks if the <see cref="T:Core.TypeCast.ConverterCollection"/> is initialized. Attempts to initialize and load the user-assembly if <see cref="!:ConverterCollection.Initialized"/> is `false`
            </summary>
            <remarks>
            see also: http://stackoverflow.com/questions/35655726/system-reflection-assembly-does-not-contain-a-definition-for-getexecutingassemb/39192534#39192534
            </remarks>
            <exception cref="T:Core.TypeCast.ConverterException"> If the Reflection required for the Initialization failed an exception is caused of 
            exception-cause: <see cref="F:Core.TypeCast.ConverterCause.ConverterAutoInitializationFailed"/></exception>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Initialize(System.String)">
            <summary>
            Initializes all attributed Converter classes, <see cref="M:Core.TypeCast.ConverterCollection.Initialize(System.Reflection.Assembly[])"/>
            </summary>
            <param name="applicationNameSpace">
            The class that holds the entry point of the application. Usually `public static Main(){...}`
            </param>
            <example> **Example:**
            ```
                ...    
                var ConverterManager = new ConverterManager();
                ConverterManager.Initialize(typeof(Program));
            ```
            </example>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Initialize(System.Type)">
            <summary>
            Initializes all attributed Converter classes, <see cref="M:Core.TypeCast.ConverterCollection.Initialize(System.Reflection.Assembly[])"/>
            </summary>
            <param name="applicationClass">
            The class that holds the entry point of the application. Usually `public static Main(){...}`
            </param>
            <example> **Example:**
            ```
                ...    
                var ConverterManager = new ConverterManager();
                ConverterManager.Initialize(typeof(Program));
            ```
            </example>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Initialize(System.Reflection.Assembly)">
            <summary>
             Initializes all attributed Converter classes, <see cref="M:Core.TypeCast.ConverterCollection.Initialize(System.Reflection.Assembly[])"/>
            </summary>
            <param name="assembly">The <see cref="T:System.Reflection.Assembly"/> to look for attributed Converter classes</param>
            <example> **Example:**
            ```
                ...    
                var ConverterManager = new ConverterManager();
                ConverterManager.Initialize(typeof(Program).Assembly);
            ```
            </example>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Initialize(System.Reflection.Assembly[])">
            <summary>
            Initializes all attributed Converter classes, unless the <see cref="T:Core.TypeCast.ConverterAttribute"/> parameter <see cref="P:Core.TypeCast.ConverterAttribute.LoadOnDemand"/> is `false`
            </summary>
            <param name="assemblies">An  <see cref="T:System.Array"/> of <see cref="T:System.Reflection.Assembly"/> to look for <see cref="T:Core.TypeCast.ConverterAttribute"/> to discover and add 
            converters into the collection</param>
            <example> **Example:**
            ```
                ...   
                var ConverterManager = new ConverterManager();
                ConverterManager.Initialize(AppDomain.CurrentDomain.GetAssemblies());
            ```
            </example>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Initialize(System.Collections.Generic.IEnumerable{System.Reflection.TypeInfo})">
            <summary>
            Initializes all attributed Converter classes, unless the <see cref="T:Core.TypeCast.ConverterAttribute"/> parameter <see cref="P:Core.TypeCast.ConverterAttribute.LoadOnDemand"/> is `false`
            </summary>
            <param name="types">The <see cref="T:System.Array"/> of <see cref="T:System.Reflection.Assembly"/> within to look for attributed Converter classes</param>
            <example> **Example:**
            ```
                ...   
                var ConverterManager = new ConverterManager();
                ConverterManager.Initialize(AppDomain.CurrentDomain.GetAssemblies());
            ```
            </example>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.Dispose(System.Boolean)">
            <summary>
            Dispose of the <see cref="P:Core.TypeCast.ConverterCollection.Items"/> and underlying static <see cref="T:Core.Singleton.Singleton`1"/> references.
            </summary>
            <param name="disposing">The state of the object disposal, to avoid unnecessary invocations during the disposing invocation.</param>
            <remarks>Invocation is only required in a few rare cases</remarks>
            <remarks>warning CA2213 can be ignored: http://stackoverflow.com/questions/34583417/code-analysis-warning-ca2213-call-dispose-on-idisposable-backing-field </remarks>
            <seealso cref="P:Core.Singleton.Singleton`1.Disposed"/>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.SetAssemblyInitialized(System.Reflection.TypeInfo)">
            <summary>
            Sets the <see cref="T:System.Reflection.Assembly"/> as initialized in <see cref="P:Core.TypeCast.ConverterCollection.AssemblyInitialized"/>
            </summary>
            <param name="type">The <see cref="T:System.Reflection.TypeInfo"/> instance from which to lookup the <see cref="P:System.Reflection.TypeInfo.Assembly"/></param>
            <returns>Returns true if the concurrent dictionary update succeeded</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.SetConverterClassInitialized(System.Reflection.TypeInfo)">
            <summary>
            Sets the <see cref="T:Core.TypeCast.Base.Converter"/> of the <see cref="T:Core.TypeCast.ConverterCollection"/> as initialized
            </summary>
            <param name="converterClass">The <see cref="!:class"/> instance of a custom converter implementation that is to be marked initialized</param>
            <returns>Returns `true` if the concurrent dictionary update succeeded</returns>
            <remarks>The class can support <see cref="T:Core.TypeCast.IConverter"/> </remarks>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.CreateConverterClassInstance(System.Type)">
            <summary>
            Creates a custom converter instance
            </summary>
            <param name="converterClass">The <see cref="!:class"/> instance of a custom converter implementation that is to be marked initialized</param>
            <returns>Returns an instance of the <see cref="!:class"/> type argument provided. `Null` if unsuccessful.</returns>
            <remarks>Use <see cref="M:Core.TypeCast.ConverterCollection.AddAllConvertersByAttribute(System.Reflection.TypeInfo)"/> to instantiate a custom converter with regard to the <see cref="T:Core.TypeCast.ConverterAttribute"/> properties</remarks>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.AddAllConvertersByAttribute(System.Reflection.TypeInfo)">
            <summary>
            Looks for a <see cref="T:Core.TypeCast.ConverterAttribute"/> from the passed <see cref="T:System.Type"/> <paramref name="type"/> to discover and add converters into the collection
            </summary>
            <param name="type">The <see cref="T:System.Reflection.TypeInfo"/> instance from which to lookup the <see cref="P:System.Reflection.TypeInfo.Assembly"/></param>
            <returns>Returns `true` if the type had a <see cref="T:Core.TypeCast.ConverterAttribute"/> which could be added to the collection</returns>
            <remarks>Use the <see cref="M:Core.TypeCast.ConverterCollection.CreateConverterClassInstance(System.Type)"/> method to instantiate a custom converter type without regard towards the <see cref="T:Core.TypeCast.ConverterAttribute"/> properties</remarks>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Core.TypeCast.ConverterCollectionLookup">
            <summary>
            A set of <see cref="T:System.Linq.IQueryable`1"/> extension methods for filtering <see cref="T:Core.TypeCast.ConverterCollection"/> items using <see cref="N:System.Linq"/>
            </summary>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionLookup.Get(System.Linq.IQueryable{Core.TypeCast.Base.Converter},Core.TypeCast.IConverter)">
            <summary>
            Looks up an object instance implementing the <see cref="T:Core.TypeCast.IConverter"/> and <see cref="T:Core.TypeCast.IConverter`2"/> interface 
            by deriving the source and target type from the generic argument parameters of the interface
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="baseTypeInstance">an object instance implementing the <see cref="T:Core.TypeCast.IConverter"/> and <see cref="T:Core.TypeCast.IConverter`2"/> interface </param>
            <returns>Returns a <see cref="T:Core.TypeCast.Base.Converter"/> matching the source and target types of the supported <see cref="T:Core.TypeCast.IConverter`2"/> interface, else `null` </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionLookup.Get(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Type)">
            <summary>
            Looks up an object <see cref="!:class"/> or <see cref="!:struct"/> <see cref="T:System.Type"/> implementing the <see cref="T:Core.TypeCast.IConverter"/> and <see cref="T:Core.TypeCast.IConverter`2"/> interface 
            by deriving the source and target type from the generic argument parameters of the interface to look up a possible candidate in <see cref="!:Items"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="baseType">an arbitrary class <see cref="T:System.Type"/> implementing the <see cref="T:Core.TypeCast.IConverter"/> and <see cref="T:Core.TypeCast.IConverter`2"/> interface </param>
            <returns>Returns a <see cref="T:Core.TypeCast.Base.Converter"/> matching the source and target types of the supported <see cref="T:Core.TypeCast.IConverter`2"/> interface, else `null` </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionLookup.Get(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Type,System.Type)">
            <summary>
            Gets the <see cref="T:Core.TypeCast.Base.Converter"/> for a given arbitrary conversion source-type <paramref name="typeFrom"/> and an arbitrary conversion target-type <paramref name="typeTo"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeFrom">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></param>
            <param name="typeTo">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></param>
            <returns>A converter instance if the query yielded a result, or `null` if no suitable <see cref="T:Core.TypeCast.Base.Converter"/> could be found.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionLookup.Get``1(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Object,System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets the <see cref="T:Core.TypeCast.Base.Converter"/> for a given arbitrary conversion source-type <paramref name="typeFrom"/> and an arbitrary conversion target-type <paramref name="typeTo"/>
            </summary>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="value">The Source- / From- object from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></param>
            <param name="hasDefault">The Boolean <see cref="P:Core.TypeCast.Base.Converter.HasDefaultFunction"/> Property to look for</param>
            <param name="loadOnDemand">Whether to look for any <see cref="T:Core.TypeCast.Base.Converter"/> in the Load-On-Demand list, if no results are yielded.</param>
            <returns>A converter instance if the query yielded a result, or `null` if no suitable <see cref="T:Core.TypeCast.Base.Converter"/> could be found.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionLookup.Get``2(System.Linq.IQueryable{Core.TypeCast.Base.Converter},``0,System.Type,System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets the <see cref="T:Core.TypeCast.Base.Converter"/> for a given arbitrary conversion source-type <paramref name="typeFrom"/> and an arbitrary conversion target-type <paramref name="typeTo"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="value">The Source- / From- object from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></param>
            <param name="typeArgument">The <see cref="P:Core.TypeCast.Base.Converter.Argument"/> Type to look for</param>
            <param name="hasDefault">The Boolean <see cref="P:Core.TypeCast.Base.Converter.HasDefaultFunction"/> Property to look for</param>
            <param name="loadOnDemand">Whether to look for any <see cref="T:Core.TypeCast.Base.Converter"/> in the Load-On-Demand list, if no results are yielded.</param>
            <returns>A converter instance if the query yielded a result, or `null` if no suitable <see cref="T:Core.TypeCast.Base.Converter"/> could be found.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ConverterCollectionLookup.Get``3(System.Linq.IQueryable{Core.TypeCast.Base.Converter},``0,``1,``2,System.Nullable{System.Boolean},System.Boolean)" -->
        <member name="M:Core.TypeCast.ConverterCollectionLookup.Get``1(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Type,System.Type,System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Gets the <see cref="T:Core.TypeCast.Base.Converter"/> for a given arbitrary conversion source-type <paramref name="typeFrom"/> and an arbitrary conversion target-type <paramref name="typeTo"/>
            </summary>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeFrom">The <see cref="P:Core.TypeCast.Base.Converter.From"/> Type to look for</param>
            <param name="typeArgument">The <see cref="P:Core.TypeCast.Base.Converter.Argument"/> Type to look for</param>
            <param name="hasDefault">The Boolean <see cref="P:Core.TypeCast.Base.Converter.HasDefaultFunction"/> Property to look for</param>
            <param name="loadOnDemand">Whether to look for any <see cref="T:Core.TypeCast.Base.Converter"/> in the Load-On-Demand list, if no results are yielded.</param>
            <returns>A converter instance if the query yielded a result, or `null` if no suitable <see cref="T:Core.TypeCast.Base.Converter"/> could be found.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionLookup.Get(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo,System.Reflection.TypeInfo,System.Reflection.TypeInfo,System.Reflection.TypeInfo,System.Nullable{System.Boolean},System.Boolean,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)">
            <summary>
            Gets the <see cref="T:Core.TypeCast.Base.Converter"/> for a given arbitrary conversion source-type <paramref name="typeFrom"/> and an arbitrary conversion target-type <paramref name="typeTo"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeFrom">The <see cref="P:Core.TypeCast.Base.Converter.From"/> Type to look for</param>
            <param name="typeTo">The <see cref="P:Core.TypeCast.Base.Converter.To"/> Type to look for</param>
            <param name="typeArgument">The <see cref="P:Core.TypeCast.Base.Converter.Argument"/> Type to look for</param>
            <param name="typeBase">The <see cref="P:Core.TypeCast.Base.Converter.BaseType"/> Type to look for</param>
            <param name="hasDefaultFunction">The Boolean <see cref="P:Core.TypeCast.Base.Converter.HasDefaultFunction"/> Property to look for</param>
            <param name="isStandard">The Boolean <see cref="P:Core.TypeCast.Base.Converter.Standard"/> property to look for</param>
            <param name="loadOnDemand">Whether to look for any <see cref="T:Core.TypeCast.Base.Converter"/> in the Load-On-Demand list, if no results are yielded.</param>
            <param name="typeFromIsGenericType">Whether <paramref name="typeFrom"/> is generic, in cases of unboxing to a sub-type, as may happen with <see cref="T:System.Nullable`1"/></param>
            <param name="typeToIsGenericType">Whether <paramref name="typeTo"/> is generic, in cases of unboxing to a sub-type, as may happen with <see cref="T:System.Nullable`1"/></param>
            <param name="functionName">A search-string to be contained in the <see cref="P:Core.TypeCast.Base.Converter.Function"/> or<see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/> to filter through</param>
            <param name="attributeName">A search-string to be contained in the <see cref="P:Core.TypeCast.ConverterAttribute.Name"/> to filter through</param>
            <returns>A converter instance if the query yielded a result, or `null` if no suitable <see cref="T:Core.TypeCast.Base.Converter"/> could be found.</returns>
            <remarks>note that invocation of <see cref="M:Core.TypeCast.ConverterCollectionLookup.Get(System.Linq.IQueryable{Core.TypeCast.Base.Converter},Core.TypeCast.IConverter)"/> may instantiate and thus initializes any required converters referenced in <see cref="!:loadOnDemandConverters"/>
            </remarks>
            <remarks>`new Nullable&lt;int>(5).GetType().IsConstructedGenericType` will yield `false` due to boxing steps during the Reflection process. 
            As such use the strictly typed <seealso cref="!:Get&lt;TOut&gt;(object,bool,bool)"/></remarks>
            <exception cref="T:Core.TypeCast.ConverterCollectionException">Throws an exception if the lookup yielded a null reference or an internal error.</exception>
        </member>
        <member name="T:Core.TypeCast.DependencyInjectionException">
            <summary>
                The Exception-type which is raised exclusively by the <see cref="T:Core.TypeCast.Base.DependencyInjection`1" />  class
            </summary>
        </member>
        <member name="M:Core.TypeCast.DependencyInjectionException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the  <see cref="T:Core.TypeCast.DependencyInjectionException" /> class. Allows passing 
                an optional user <paramref name="message" /> and <paramref name="innerException"/>.
            </summary>
            <param name="message">
                The error message that explains the reason for the exception. 
            </param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
        </member>
        <member name="M:Core.TypeCast.DependencyInjectionException.GetMessage">
            <summary>
                Gets the exception message.
            </summary>
        </member>
        <member name="T:Core.TypeCast.ObjectExtension">
            <summary>The object extension methods to convert an object of an unrestricted unknown type `TIn` to an unrestricted known type `TOut`.</summary>
            <summary>The object extension methods to convert an object of an unrestricted unknown type `TIn` to an unrestricted known type `TOut`.</summary>
            <summary>The object extension methods to convert an object of an unrestricted unknown type `TIn` to an unrestricted known type `TOut`.</summary>
            <summary>The object extension methods to convert an object of an unrestricted unknown type `TIn` to an unrestricted known type `TOut`.</summary>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.Transform``1(``0,System.Enum,System.Boolean)">
            <summary>
            `Transform`is similar to <see cref="!:ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/> but should be preferred in situations wherein the input and output type are similar or the same. 
            All Types involved in the conversion must be from the same namespace. If the optional parameter `strictTypeCheck` is set to `true`, an exception will be thrown if the input and output types do not match.
            This does not hold true for the "Try" version, which has no optional `strictTypeCheck` argument.
            </summary>
            <typeparam name="TOut">The output <see cref="T:System.Type"/> which must equal the input type of the own value <paramref name="self"/></typeparam>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="functionAlias">Applies an optional search string to the filter lookup, as Transform functions are allowed to be ambivalent 
            i.e. have same argument and return types</param>
            <param name="strictTypeCheck">Whether the input and output arguments are of the same type, otherwise an exception is thrown, when set to true.</param>
            <returns>Returns the transformed value of the <see cref="T:System.Type"/> as <typeparamref name="TOut" /> </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.Transform``1(``0,System.Object,System.Enum,System.Boolean,System.Boolean)" -->
        <member name="M:Core.TypeCast.ObjectExtension.Transform``1(System.Object,System.Enum)">
            <summary>
            `Transform`is similar to <see cref="!:ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/> but should be preferred in situations wherein the input and output type are similar or the same. 
            All Types involved in the conversion must be from the same namespace. If the optional parameter `strictTypeCheck` is set to `true`, an exception will be thrown if the input and output types do not match.
            This does not hold true for the "Try" version, which has no optional `strictTypeCheck` argument.
            </summary>
            <typeparam name="TOut">The output <see cref="T:System.Type"/> which must equal the input type of the own value <paramref name="self"/></typeparam>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="functionAlias">Applies an optional search string to the filter lookup, as Transform functions are allowed to be ambivalent 
            i.e. have same argument and return types</param>
            <returns>Returns the transformed value of the <see cref="T:System.Type"/> as <typeparamref name="TOut" /> </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.Transform``1(System.Object,System.Object,System.Enum,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.Transform``1(``0,System.Object,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.Transform``2(System.Object,System.Object,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.Transform``1(``0,System.Type,System.Object,System.String,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.Transform``1(System.Object,System.Object,System.Type,System.Type,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.Transform(System.Object,System.Object,System.Type,System.Type,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.Transform(System.Object,Core.TypeCast.Base.Converter@,System.Object,System.Type,System.Type,System.String,System.Boolean,System.Boolean)" -->
        <member name="M:Core.TypeCast.ObjectExtension.Transform``2(``0,System.Func{``0,``1},System.Enum,System.Boolean)">
            <summary>
            `Transform`is similar to <see cref="!:ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/> but should be preferred in situations wherein the input and output type are similar or the same. 
            All Types involved in the conversion must be from the same namespace. If the optional parameter `strictTypeCheck` is set to `true`, an exception will be thrown if the input and output types do not match.
            This does not hold true for the "Try" version, which has no optional `strictTypeCheck` argument.
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="converterAction">A function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="addWithAttributeName">An Enum containing an enumeration of aliases for the converters for unique identification and lookup</param>
            <param name="throwException">Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown</param>
            <returns>Returns the transformed value of the <see cref="T:System.Type"/> as <typeparamref name="TOut" /> </returns>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.Transform``2(``0,System.Func{``0,``1},System.String,System.Boolean)">
            <summary>
            Alias for <see cref="!:ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/> with parameter `transform` set to true, to allow equality of the input and output types.
            Use Transform when the input and output <see cref="T:System.Type"/> match, otherwise an exception is raised.
            </summary>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="converterAction">A function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="addWithAttributeName">An Enum containing an enumeration of aliases for the converters for unique identification and lookup</param>
            <param name="throwException">Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>Returns the transformed value of the <see cref="T:System.Type"/> as <typeparamref name="TOut" /> </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.TryTransform(System.Object,System.Object@,System.Object,System.Type,System.Type,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.TryTransform``2(``0,``1@,System.Object,System.Type,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.TryTransform``2(System.Object,``1@,System.Object,System.String,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.TryTransform``3(``1,``2@,System.Object,System.String,System.Boolean,System.Boolean)" -->
        <member name="M:Core.TypeCast.ObjectExtension.CheckTransformTypes``1(System.Object,System.Boolean)">
            <summary>
            If the parameter `strictTypeCheck` is set to `true`, an exception will be thrown if the input and output types do not match. 
            If `strictTypeCheck` is set to `false` an exception is thrown if the <see cref="P:System.Type.Namespace"/> of the input <typeparamref name="TIn"/> and output type <typeparamref name="TOut"/> do not match. 
            This does not hold true for the "Try" version, which has no optional `StrictTypeCheck` invocation.
            </summary>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="strictTypeCheck"> If the parameter `strictTypeCheck` is set to `true`, an exception will be thrown if the input and output types do not match. </param>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.CastTo``1(System.Object,``0)">
            <summary>
                Converts from an arbitrary boxed <see cref="T:System.Type" /> <see cref="T:System.Object" /> to a strict unrestricted type <typeparamref name="TOut" />
            </summary>
            <typeparam name="TOut">The target-<see cref="T:System.Type"/> of the <paramref name="self" /> to be converted</typeparam>
            <param name="self">The own instance which invokes the static extension method</param>
            <param name="defaultValue">A optional default value of the target-<see cref="T:System.Type"/><typeparamref name="TOut"/></param>
            <returns>Returns the converted value of <see cref="T:System.Type"/> <typeparamref name="TOut" /> </returns>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of <see cref="T:System.Type"/> <see cref="T:Core.TypeCast.ConverterException" />if the conversion fails</exception>
            <remarks>Use <see cref="!:TryConvertonvert&lt;TOut&gt;" /> instead if you do not want to raise any <see cref="T:Core.TypeCast.ConverterException" /> 
            that might occur during the conversion process.</remarks>
            <remarks>note: The <see cref="T:Core.TypeCast.ConverterCollection"/> is lazy instantiated upon the first invocation of the method</remarks>
            <seealso cref="!:TryCast&lt;TIn, TOut&gt;(TIn, out TOut, TOut, bool, bool)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.CastTo``2(System.Nullable{``0},``1,System.Boolean)" -->
        <member name="M:Core.TypeCast.ObjectExtension.CastTo``2(``0,``1)">
            <summary>
                Converts from an arbitrary <see cref="T:System.Nullable`1"/> <see cref="T:System.Type" /> to a strict unrestricted type <typeparamref name="TOut" />
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <param name="self">The own instance which invokes the static extension method</param>
            <param name="defaultValue">A optional default value of the target-<see cref="T:System.Type"/><typeparamref name="TOut"/></param>
            <returns>Returns the converted value of <see cref="T:System.Type"/> <typeparamref name="TOut" /> </returns>
            <example>
                <code>
            ```cs    
                  // Converter: Nullable&lt;int> --> float
                  var cc = ConverterCollection.CurrentInstance;
                  cc.Add((int? n) =>
                  {
                          return (float)(n ?? 0);
                  });
                  var nullSingle = new Nullable&lt;int>(5).CastTo&lt;int?, float>();
            ```
            </code>
            </example>
            <remarks>Singled out and explicitly implemented for future reference</remarks>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException" />if the conversion fails</exception>
            <remarks>note: The <see cref="T:Core.TypeCast.ConverterCollection"/> is lazy instantiated upon the first invocation of the method</remarks>
            <seealso cref="!:TryCast&lt;TIn, TOut&gt;(TIn, out TOut, TOut, bool, bool)"/>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.CastTo(System.Object,System.Type,System.Object)">
            <summary>
                Converts from an arbitrary unrestricted <see cref="T:System.Type" /> to a strict unrestricted type <paramref name="typeTo"/> 
            </summary>
            <param name="self">The own instance which invokes the static extension method</param>
            <param name="typeTo">The target <see cref="T:System.Type"/> to which to convert the <see cref="T:System.Type"/> of <see cref="!:self"/> to</param>
            <param name="defaultValue">A optional default value of the target-<see cref="T:System.Type"/><typeparamref name="TOut"/></param>
            <returns>Returns the converted value of <see cref="T:System.Type"/> <typeparamref name="TOut" /> </returns>
            <example>
                <code>
            ```cs    
                  // Converter: Nullable&lt;int> --> float
                  var cc = ConverterCollection.CurrentInstance;
                  cc.Add((int? n) =>
                  {
                          return (float)(n ?? 0);
                  });
                  var nullSingle = new Nullable&lt;int>(5).CastTo(typeof(float));
            ```
            </code>
            </example>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException" />if the conversion fails</exception>
            <remarks>Use <see cref="!:TryConvert&lt;TIn,TOut&gt;" /> instead if you do not want to raise <see cref="T:Core.TypeCast.ConverterException" />
            </remarks>
            <remarks>note: The <see cref="T:Core.TypeCast.ConverterCollection"/> is lazy instantiated upon the first invocation of the method</remarks>
            <seealso cref="!:TryCast(object, Type, out object, object, bool)"/>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.TryCast``2(``0,``1@,``1,System.Boolean,System.Boolean,Core.TypeCast.IConvertContext)">
            <summary>The cast method following the `Try` function convention of the .Net Framework, returning a <see cref="T:System.Boolean"/> success 
            status rather than throwing an <see cref="T:System.Exception"/> upon a failed conversion.</summary>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="result">The variable reference to which the conversion result is assigned.</param>
            <param name="defaultValue">An optional default value of the target-<see cref="T:System.Type"/><typeparamref name="TOut"/></param>
            <param name="throwException">Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown</param>
            <param name="unboxObjectType">Whether to determine the type from the parameters <paramref name="self"/> and <paramref name="result"/> respectively.</param>
            <param name="contextInstance">An optional context instance, providing current parameters of the conversion process and context.</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>The success state as <see cref="T:System.Boolean" /> indicating if the conversion succeeded (`true`) or failed (`false`).</returns>
            <example>
                <code>
            ```cs    
                  using System.Drawing;
                  var somestr = "test";
                  Image result;
                  if( test.TryCast(out result) == true )
                  {
                    Console.WriteLine("Image successfully created");
                  }
            ```
            </code>
            </example>
            <remarks>
                The methods follows the "Try" convention. It accepts an object "value" and an out parameter <paramref name="result"/> of type <typeparamref name="TOut"/>. 
                If the attempt to cast the value of <paramref name="self"/> into <see cref="T:System.Type"/> <typeparamref name="TOut"/> succeeds, `true` is returned, else `result = default(T)`
                and false is returned.
            </remarks>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException" />if the conversion fails</exception>
            <remarks>note: The <see cref="T:Core.TypeCast.ConverterCollection"/> is lazy instantiated upon the first invocation of the method</remarks>
            <seealso cref="!:GetConverterOrDefault&lt;TIn, TOut&gt;(TIn, out Converter, out TOut, Type, bool, bool)"/>
            <seealso cref="!:InvokeConvert&lt;TIn, TOut&gt;(TIn, out TOut, object, bool, Converter)"/>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.TryCast(System.Object,System.Type,System.Object@,System.Object,System.Boolean,Core.TypeCast.IConvertContext)">
            <summary>The cast method following the `Try` function convention of the .Net Framework, returning a <see cref="T:System.Boolean"/> success 
            status rather than throwing an <see cref="T:System.Exception"/> upon a failed conversion.</summary>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="typeTo">The target <see cref="T:System.Type"/> to which to convert the <see cref="T:System.Type"/> of <see cref="!:self"/> to</param>
            <param name="result">The variable reference to which the conversion result is assigned.</param>
            <param name="defaultValue">An optional default value of the target-<see cref="T:System.Type"/><typeparamref name="TOut"/></param>
            <param name="throwException">Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown</param>
            <param name="contextInstance">An optional context instance, providing current parameters of the conversion process and context.</param>
            <typeparam name="TOut"></typeparam>
            <returns>The success state as <see cref="T:System.Boolean" /> indicating if the conversion succeeded (`true`) or failed (`false`).</returns>
            <remarks>
                The methods follows the "Try" convention. It accepts an object "value" and an out parameter <paramref name="result"/> of type <typeparamref name="TOut"/>. 
                If the attempt to cast the value of <paramref name="self"/> into <see cref="T:System.Type"/> <typeparamref name="TOut"/> succeeds, `true` is returned, else `result = default(T)`
                and false is returned.
            </remarks>
            <remarks>For strict typing use <see cref="!:TryCast&lt;TIn, TOut&gt;(TIn, out TOut, TOut, bool, bool)"/> wherever possible</remarks>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException" />if the conversion fails</exception>
            <remarks>note: The <see cref="T:Core.TypeCast.ConverterCollection"/> is lazy instantiated upon the first invocation of the method</remarks>
            <seealso cref="!:GetConverterOrDefault&lt;TIn, TOut&gt;(TIn, out Converter, out TOut, Type, bool, bool)"/>
            <seealso cref="!:InvokeConvert&lt;TIn, TOut&gt;(TIn, out TOut, object, bool, Converter)"/>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.ConvertTo``2(``0,System.Object,System.Boolean)">
            <summary>The convert method following can involve up to three different types to convert an arbitrary input type to another arbitrary output type.
            using a third model parameter which encapsulates all data and fields required for the conversion function. 
            A maximum of three involving types by design to enforce adherence to the single responsibility principle.</summary>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="model">An model-instance, for instance a Data-Transfer-Object/DTO that encapsulates further data parameters for the conversion process
            to the target-<see cref="T:System.Type"/><typeparamref name="TOut"/></param>
            <param name="withContext">Whether to provide a conversion context with the model argument set within. 
            A context provides meta-data about the conversion arguments and is rarely needed.</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>Returns the converted value of <see cref="T:System.Type"/> <typeparamref name="TOut" /> </returns>
            <example>
                <code>
            ```cs    
                  using System.Drawing;
                   Func&lt;Point, Rectangle, Size> delAnyFunc = (ap, rect) =>
                   {
                       if(ap.X * ap.Y > rect.X * rect.Y)
                       {
                           return new Size(ap.X, ap.Y);
                       }
                       return new Size(rect.X, rect.Y);
                   };
                   ConverterCollection.CurrentInstance.Add(delAnyFunc);
                   Point somePoint = new Point(1, 2);
                   Size size = somePoint.ConvertTo&lt;Point, Size>(new Rectangle(2, 2, 4, 4));
            ```
            </code>
            </example>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException" />if the conversion fails</exception>
            <remarks>note: The <see cref="T:Core.TypeCast.ConverterCollection"/> is lazy instantiated upon the first invocation of the method</remarks>
            <seealso cref="!:TryConvert&lt;TOut&gt;(object, out TOut, object, bool)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.ConvertTo``1(System.Object,System.Object,System.Boolean)" -->
        <member name="M:Core.TypeCast.ObjectExtension.TryConvert``1(System.Object,``0@,System.Object,System.Boolean,System.Boolean)">
            <summary>The convert method following the `Try` convention, of the .Net Framework, returning a <see cref="T:System.Boolean"/> success 
            status rather than throwing an <see cref="T:System.Exception"/> upon a failed conversion. Conversion can involve up to three different types to convert 
            an arbitrary input type to another arbitrary output type, by using a third model parameter which encapsulates all data and fields required for the conversion function. 
            A maximum of three involving types is by design, to enforce adherence to the single responsibility principle.</summary>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="result">The variable reference to which the conversion result is assigned.</param>
            <param name="model">An model-instance, for instance a Data-Transfer-Object/DTO that encapsulates further data parameters for the conversion process
            to the target-<see cref="T:System.Type"/><typeparamref name="TOut"/></param>
            <param name="throwException">Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown</param>
            <param name="withContext">Whether to provide a conversion context with the model argument set within. 
            <see cref="T:System.Type" /> <typeparamref name="TOut"/></param>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>Returns the converted value of <see cref="T:System.Type"/> <typeparamref name="TOut" /> </returns>
            <returns>The success state as <see cref="T:System.Boolean" /> indicating if the conversion succeeded (`true`) or failed (`false`).</returns>
            <remarks>
                The methods follows the "Try" convention. It accepts an object "value", an out parameter <paramref name="result"/> of type <typeparamref name="TOut"/> and a data-model. 
                If the attempt to convert the value of <paramref name="self"/> into <see cref="T:System.Type"/> <typeparamref name="TOut"/> succeeds, `true` is returned, else `result = default(T)`
                and false is returned.
            </remarks>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException" />if the conversion fails</exception>
            <remarks>note: The <see cref="T:Core.TypeCast.ConverterCollection"/> is lazy instantiated upon the first invocation of the method</remarks>
            <seealso cref="!:GetConverterOrDefault&lt;TIn, TOut&gt;(TIn, out Converter, out TOut, Type, Type, bool, bool, bool)"/>
            <seealso cref="!:InvokeConvert&lt;TIn, TOut&gt;(TIn, out TOut, object, bool, Converter)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.TryConvert``3(``0,``1@,``2,System.Boolean,System.Boolean)" -->
        <member name="M:Core.TypeCast.ObjectExtension.GetConverterOrDefault``2(``0,Core.TypeCast.Base.Converter@,``1@,System.Type,System.Type,System.Type,System.Boolean,System.Boolean,System.String)">
            <summary>A method wrapper to safely lookup the required converter instance for the conversion and intercept possible exceptions.
            The method returns <see cref="T:System.Boolean"/> `true` if the <paramref name="result"/> value is already determined, in case of <paramref name="self"/> 
            already having <see cref="T:System.Type"/> <typeparamref name="TOut"/>
            </summary>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="converter">The <see cref="T:Core.TypeCast.Base.Converter"/> instance for the corresponding types <typeparamref name="TIn"/> and <typeparamref name="TOut"/></param>
            <param name="result">  The converted result of Type <typeparamref name="TOut" />. </param>
            <param name="throwException">Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown</param>
            <param name="unboxObjectType"> in case the type is boxed and TIn set to `object`, use <paramref name="typeIn" /> to override the unboxed source <see cref="T:System.Type" /></param>
            <param name="typeArgument">The argument <see cref="T:System.Type"/> of the `model` as used in <see cref="!:ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/></param>
            <param name="typeTo">The target <see cref="T:System.Type"/> to which to convert the <see cref="T:System.Type"/> of <see cref="!:self"/> to</param>
            <param name="typeBase">The base-type <see cref="T:System.Type"/> to which to convert the <see cref="T:System.Type"/> of <see cref="!:self"/> to</param>
            <param name="attributeName">A search-string to be contained in the <see cref="P:Core.TypeCast.ConverterAttribute.Name"/> to filter through</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>The result state as <see cref="T:System.Boolean" /> indicating if the conversion is already finished (`true`) or still pending (`false`).</returns>
            <remarks>
                Note that the <see cref="T:System.Type" /> `object` as `TOut` or set via `typeOut` is allowed although such a case is not sensible, except under special
                circumstances, including for testing and debugging
            </remarks>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.InvokeConvert``2(``0,``1@,System.Object,System.Boolean,Core.TypeCast.Base.Converter,Core.TypeCast.IConvertContext,System.String)">
            <summary>A method wrapper to safely invoke the converter functions and intercept possible exceptions, returning the conversion status as a <see cref="T:System.Boolean"/>.</summary>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="result">  The converted result of Type <typeparamref name="TOut" />. </param>
            <param name="defaultValue">An optional default value for the given type, which must not be null, otherwise an <see cref="T:Core.TypeCast.ConverterException" /> may be thrown.</param>
            <param name="throwException">Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown</param>
            <param name="converter">The <see cref="T:Core.TypeCast.Base.Converter"/> instance for the corresponding types <typeparamref name="TIn"/> and <typeparamref name="TOut"/></param>
            <param name="contextInstance">>An optional context instance, providing current parameters of the conversion process and context.</param>
            <param name="caller">The caller method name which is automatically filled-in via the <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>, and used for context information.</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>The success state as <see cref="T:System.Boolean" /> indicating if the conversion succeeded (`true`) or failed (`false`).</returns>
            <exception cref="T:System.Exception">A generic exception that occurred during the invocation of the conversion functions</exception>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException" />if the conversion fails</exception>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.SetContext``2(Core.TypeCast.IConvertContext,System.Object,System.Boolean,Core.TypeCast.Base.Converter,System.String)">
            <summary>
            Updates a ConvertContext instance with the parameters provided
            </summary>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="result">  The converted result of Type <typeparamref name="TOut" />. </param>
            <param name="defaultValue">an optional default value for the given type, which must not be null, otherwise an <see cref="T:Core.TypeCast.ConverterException" /> may be thrown.</param>
            <param name="throwException">Whether to throw exceptions. `false` by default such that no <see cref="T:Core.TypeCast.ConverterException"/> is thrown</param>
            <param name="converter">The <see cref="T:Core.TypeCast.Base.Converter"/> instance for the corresponding types <typeparamref name="TIn"/> and <typeparamref name="TOut"/></param>
            <param name="contextInstance">>An optional context instance, providing current parameters of the conversion process and context.</param>
            <param name="caller">The caller method name which is automatically filled-in via the <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>, and used for context information.</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>An updated ConvertContext instance if one was passed in, else `null` </returns>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.CanConvertTo``2(``0,``1)">
            <summary>
            Checks if the value of an arbitrary <see cref="T:System.Type"/> can be converted to a given <see cref="T:System.Type"/> <paramref name="self"/>,
            in analogy to the virtual method <see cref="!:System.ComponentModel.TypeConverter.CanConvertFrom"/> 
            </summary>
            <param name="self">The own instance of any unrestricted <see cref="T:System.Type"/>, which invokes the static extension method.</param>
            <param name="target">The own instance of any unrestricted <see cref="T:System.Type"/>, which invokes the static extension method.</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>Returns `true` if the own value is equal to the <see cref="!:default"/>, else `false` is returned.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.CanConvertTo``2(System.Object,``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.CanConvertTo``2(``0,System.Type,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.ObjectExtension.CanConvertTo``1(``0,System.Type,System.Type)" -->
        <member name="M:Core.TypeCast.ObjectExtension.CanConvertTo``1(``0,System.Type)">
            <summary>
            Checks if the value of an arbitrary <see cref="T:System.Type"/> can be converted to a given <see cref="T:System.Type"/> <paramref name="self"/>,
            in analogy to the virtual method <see cref="!:System.ComponentModel.TypeConverter.CanConvertFrom"/> 
            </summary>
            <param name="self">The own instance of any unrestricted <see cref="T:System.Type"/>, which invokes the static extension method.</param>
            <param name="typeTo">The target <see cref="T:System.Type"/> to which to convert the <see cref="T:System.Type"/> of <see cref="!:self"/> to</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type" />from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>Returns `true` if the own value is equal to the <see cref="!:default"/>, else `false` is returned.</returns>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.CanConvertTo``1(System.Object)">
            <summary>
            Checks if the value of an arbitrary <see cref="T:System.Type"/> can be converted to a given <see cref="T:System.Type"/> <paramref name="self"/>,
            in analogy to the virtual method <see cref="!:System.ComponentModel.TypeConverter.CanConvertFrom"/> 
            </summary>
            <param name="self">The own instance of any unrestricted <see cref="T:System.Type"/>, which invokes the static extension method.</param>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <returns>Returns `true` if the own value is equal to the <see cref="!:default"/>, else `false` is returned.</returns>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.IsDefaultValue``1(``0)">
            <summary>
            Checks if the value of an arbitrary <see cref="T:System.Type"/> is equal to its <see cref="!:default"/>
            </summary>
            <typeparam name="TIn">An arbitrary <see cref="T:System.Type"/></typeparam>
            <param name="self">The own instance of any unrestricted <see cref="T:System.Type"/>, which invokes the static extension method.</param>
            <returns>Returns `true` if the own value is equal to the <see cref="!:default"/>, else `false` is returned.</returns>
        </member>
        <member name="M:Core.TypeCast.ObjectExtension.IsDefaultValue``1(System.Object)">
            <summary>
            Checks if the value of an arbitrary <see cref="T:System.Type"/> <typeparamref name="TIn"/> is equal to its <see cref="!:default"/>
            </summary>
            <typeparam name="TIn">An arbitrary <see cref="T:System.Type"/></typeparam>
            <param name="self">The own instance of any unrestricted <see cref="T:System.Type"/>, which invokes the static extension method.</param>
            <returns>Returns `true` if the own value is equal to the <see cref="!:default"/>, else `false` is returned.</returns>
        </member>
        <member name="T:Core.TypeCast.IConvertContext">
            <summary>
            The common <see cref="T:Core.TypeCast.IConvertContext"/> interface.
            </summary>
        </member>
        <member name="T:Core.TypeCast.IFactory`3">
            <summary>
            The generic, common factory interface for declaring factories creating arbitrary object instances requiring up to two arguments. 
            Use a container type such as <see cref="!:Tuple"/> or <see cref="!:struct"/> as second parameter <typeparamref name="TIn2"/> if more parameters are required.
            </summary>
            <typeparam name="TInstance">The <see cref="!:Type"/> of the instances to create and return by the factory method <see cref="M:Core.TypeCast.IFactory`3.Create(`1)"/>
            and <see cref="M:Core.TypeCast.IFactory`3.Create(`1,`2)"/>.</typeparam>
            <typeparam name="TIn1">The parameter type used for defining the instance creation process in the factory method <see cref="M:Core.TypeCast.IFactory`3.Create(`1)"/></typeparam>
            <typeparam name="TIn2">The 2. parameter type used for defining the instance creation process in the factory method <see cref="M:Core.TypeCast.IFactory`3.Create(`1)"/> 
            and <see cref="M:Core.TypeCast.IFactory`3.Create(`1,`2)"/></typeparam>
        </member>
        <member name="M:Core.TypeCast.IFactory`3.Create(`1)">
            <summary>
            
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:Core.TypeCast.IFactory`3.Create(`1,`2)">
            <summary>
            Creates new <typeparamref name="TInstance"/> instances dependent on the parameter type <typeparamref name="TIn1"/> and optionally <see cref="!:Type"/> <typeparamref name="TIn2"/>
            </summary>
            <param name="parameter">The 1. parameter of <see cref="!:Type"/> <typeparamref name="TIn1"/> defining instance creation.</param>
            <param name="parameterSet">The 2. optional set of parameters or single parameter of <see cref="!:Type"/> <typeparamref name="TIn2"/> defining instance creation.</param>
            <returns>Returns a new instance of <typeparamref name="TInstance"/> upon success</returns>
        </member>
        <member name="T:Core.TypeCast.Converter`2">
            <summary>
            The generic, strictly-typed converter class, for type casting and simple conversions.
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <remarks>the class is declared sealed as the only converter implementation must be herein and no further implementation must be allowed, 
            to enforce decoupling between arbitrary converter logic with a guaranteed implementation of the underlying converter-container in question</remarks>
        </member>
        <member name="M:Core.TypeCast.Converter`2.#ctor(System.Func{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converter`2"/> class.
            </summary>
            <param name="converter"> The converter function. <seealso cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws a <see cref="T:Core.TypeCast.ConverterException"/> caused by <see cref="F:Core.TypeCast.ConverterCause.ConverterArgumentNull"/>
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`2.#ctor(System.Func{`0,`1,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converter`2"/> class.
            </summary>
            <param name="converterDefault"> The converter default function which takes a default-value parameter as the second argument  <seealso cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/>
             wherein <typeparamref name="TIn"/> is the source / from <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/>, and 
            <typeparamref name="TOut"/> is the target / to <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/>
            </param>
            <param name="argument">The <seealso cref="T:System.Type"/> of the argument passed to <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/></param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws a <see cref="T:Core.TypeCast.ConverterException"/> caused by <see cref="F:Core.TypeCast.ConverterCause.ConverterArgumentNull"/>
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`2.#ctor(System.Func{`0,System.Object,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converter`2"/> class.
            </summary>
            <param name="converterDefaultAnyType"> The converter default function which takes a default-value parameter as the second argument  <seealso cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/>
             wherein <typeparamref name="TIn"/> is the source / from <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/>, and 
            <typeparamref name="TOut"/> is the target / to <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/>
            </param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws a <see cref="T:Core.TypeCast.ConverterException"/> caused by <see cref="F:Core.TypeCast.ConverterCause.ConverterArgumentNull"/>
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`2.#ctor(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converter`2"/> class.
            </summary>
            <param name="converterDefault"> The converter default function which takes a default-value parameter as the second argument  <seealso cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/>
             wherein <typeparamref name="TIn"/> is the source / from <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/>, and 
            <typeparamref name="TOut"/> is the target / to <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/>
            </param>
            <param name="argument">The <seealso cref="T:System.Type"/> of the argument passed to <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/></param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws a <see cref="T:Core.TypeCast.ConverterException"/> caused by <see cref="F:Core.TypeCast.ConverterCause.ConverterArgumentNull"/>
            </exception>
        </member>
        <member name="T:Core.TypeCast.ConverterCollectionFilters">
            <summary>
            A set of <see cref="T:System.Linq.IQueryable`1"/> extension methods for filtering <see cref="T:Core.TypeCast.ConverterCollection"/> items using <see cref="N:System.Linq"/>
            </summary>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithFrom(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo)">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="P:Core.TypeCast.Base.Converter.From"/> set equal to <paramref name="typeFrom"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeFrom">The <see cref="P:Core.TypeCast.Base.Converter.From"/> Type to look for</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithTo(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo)">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="P:Core.TypeCast.Base.Converter.To"/> set equal to <paramref name="typeTo"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeTo">The <see cref="P:Core.TypeCast.Base.Converter.To"/> Type to look for</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithBaseType(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo)">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="P:Core.TypeCast.Base.Converter.BaseType"/> set equal to <paramref name="typeBase"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeBase">The <see cref="P:Core.TypeCast.Base.Converter.BaseType"/> Type to look for</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithArgument(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo,System.Boolean)">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="P:Core.TypeCast.Base.Converter.Argument"/> set equal to <paramref name="typeArgument"/>, or
            if that query yields no results, checks via <see cref="M:System.Reflection.TypeInfo.IsAssignableFrom(System.Reflection.TypeInfo)"/> for supported interfaces or base-classes.
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeArgument">The <see cref="P:Core.TypeCast.Base.Converter.Argument"/> Type to look for</param>
            <param name="assignableFrom">Whether to check via <see cref="M:System.Reflection.TypeInfo.IsAssignableFrom(System.Reflection.TypeInfo)"/> for supported interfaces or base-classes.r</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithStandard(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Nullable{System.Boolean})">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="P:Core.TypeCast.Base.Converter.Standard"/> set equal to <paramref name="isStandard"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="isStandard">The Boolean <see cref="P:Core.TypeCast.Base.Converter.Standard"/> property to look for</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithFromIsGenericType(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Nullable{System.Boolean})">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="!:Converter.From.IsGenericType"/> set equal to <paramref name="typeFromIsGenericType"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods 
            in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeFromIsGenericType">The Boolean <see cref="!:Converter.From.IsGenericType"/> Type-property to look for</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithToIsGenericType(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Nullable{System.Boolean})">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="!:Converter.To.IsGenericType"/> set equal to <paramref name="typeToIsGenericType"/>
            </summary>
            <param name="query">The typeToIsGenericType <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension 
            methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeToIsGenericType">The Boolean <see cref="!:Converter.To.IsGenericType"/> Type-property to look for</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithFunctionName(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.String)">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have their Delegate Name set to contain a case sensitive string of <paramref name="containedName"/>
            </summary>
            <param name="query">The typeToIsGenericType <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension 
            methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="containedName">A search-string to be contained in the Method's Name to filter through</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithConverterAttributeName(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.String,System.Boolean)">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="!:Converter.Attribute.Name"/> set equal to <paramref name="containedName"/>
            </summary>
            <param name="query">The typeToIsGenericType <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension 
            methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="containedName">A search-string to be contained in the <see cref="P:Core.TypeCast.ConverterAttribute.Name"/> to filter through</param>
            <param name="caseSensitive">Whether to search case sensitive (`true`) or not (`false`)</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.WithDefaultFunction(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Nullable{System.Boolean})">
            <summary>
            Filters items in <see cref="T:Core.TypeCast.ConverterCollection"/> which have <see cref="P:Core.TypeCast.Base.Converter.HasDefaultFunction"/> set equal to <paramref name="hasDefaultFunction"/>
            </summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="hasDefaultFunction">The Boolean <see cref="P:Core.TypeCast.Base.Converter.HasDefaultFunction"/> Property to look for</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionFilters.ApplyAllFilters(System.Linq.IQueryable{Core.TypeCast.Base.Converter},System.Reflection.TypeInfo,System.Reflection.TypeInfo,System.Reflection.TypeInfo,System.Reflection.TypeInfo,System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.Nullable{System.Boolean},System.String,System.String)">
            <summary>Applies all filters in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/> to an <see cref="T:System.Linq.IQueryable`1"/> instance</summary>
            <param name="query">The own <see cref="T:System.Linq.IQueryable`1"/> instance which invokes the static extension methods in <see cref="T:Core.TypeCast.ConverterCollectionFilters"/></param>
            <param name="typeFrom">The <see cref="P:Core.TypeCast.Base.Converter.From"/> Type to look for</param>
            <param name="typeTo">The <see cref="P:Core.TypeCast.Base.Converter.To"/> Type to look for</param>
            <param name="typeArgument">The <see cref="P:Core.TypeCast.Base.Converter.Argument"/> Type to look for</param>
            <param name="typeBase">The <see cref="P:Core.TypeCast.Base.Converter.BaseType"/> Type to look for</param>
            <param name="hasDefaultFunction">The Boolean <see cref="P:Core.TypeCast.Base.Converter.HasDefaultFunction"/> Property to look for</param>
            <param name="isStandard">The Boolean <see cref="P:Core.TypeCast.Base.Converter.Standard"/> property to look for</param>
            <param name="typeFromIsGenericType">The Boolean <see cref="!:Converter.From.IsGenericType"/> Type-property to look for</param>
            <param name="typeToIsGenericType">The Boolean <see cref="!:Converter.To.IsGenericType"/> Type-property to look for</param>
            <param name="functionName">A search-string to be contained in the <see cref="P:Core.TypeCast.Base.Converter.Function"/> or<see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/> to filter through</param>
            <param name="attributeName">A search-string to be contained in the <see cref="P:Core.TypeCast.ConverterAttribute.Name"/> to filter through</param>
            <returns>Returns a new filtered query as <see cref="T:System.Linq.IQueryable`1"/> </returns>
            <seealso cref="!:ConverterCollection.Get(TypeInfo, TypeInfo, TypeInfo, bool?, bool, bool?, bool?, bool?)"/>
        </member>
        <member name="T:Core.TypeCast.ConverterMethodAttribute">
            <summary>
            Use <see cref="T:Core.TypeCast.ConverterMethodAttribute"/> to declare a method in an arbitrary class as a logical Converter function. 
            The only restriction towards the attributed method is a maximum of two defined function parameters. This limitation is by design, 
            to advocate the use of the single responsibility principle, and building complex converters out of smaller ones, as 
            implemented by a different library.
            Take a look at the examples and documentation for more information.
            </summary>
            <remarks>
            The attribute provides collective initialization through the <see cref="T:Core.TypeCast.ConverterCollection"/> class.
            </remarks>
            <example> **Example:**  Declaring an arbitrary class method to be loaded and encapsulated into a converter instance
            <code>
            ```cs
                [Converter(loadOnDemand: false, nameSpace: nameof(Program.BioCode.DNA))]
                public class StringToDNA {
                    ... 
                    // Constructor with dependency injection
                    public StringToDNA(IConverterCollection collection) 
                    { 
                        ... collection.Add((Func&lt;string, DNA>)this.Convert); ...
                    }
                    // method added explicitly by the constructor supporting converter-dependency-injection
                    // Note: It is recommended to derive the class `StringToDNA`  from `ConverterCollectionDependency`
                    public object Convert(object valueIn)
                    { 
                        ... 
                    }
                    // method loaded automatically, through attribution
                    [ConverterMethod]        
                    public DNA Convert(string valueIn) 
                    { 
                        ... 
                    }
                    ...
                }
            ```
            </code>
            </example>
            Reference: <seealso cref="P:Core.TypeCast.Base.Converter.Function"/>, <seealso cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/>
        </member>
        <member name="M:Core.TypeCast.ConverterMethodAttribute.#ctor(System.Boolean,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterMethodAttribute"/> class, to declare a custom <see cref="T:Core.TypeCast.Base.Converter"/> function
            </summary>
            <param name="loadOnDemand">Set to `true` to allow joint initialization by the lazy instancing of the <see cref="T:Core.TypeCast.ConverterCollection"/> <see cref="N:Core.Singleton"/>  </param>
            <param name="isStatic"> Set to `true` to invoke the method with `this` reference set to null, otherwise with an instance reference passed. Default is `true`. </param>
            <param name="nameSpace"> The namespace as a string, ideally set via the <see cref="!:nameof"/> operator to group converters and enable lazy-loading upon first use.  </param>
            <param name="dependencyInjection">
            Whether the declaring converter class is instantiated via dependency Injection.
            </param>
        </member>
        <member name="P:Core.TypeCast.ConverterMethodAttribute.BaseType">
            <summary>
            Gets or sets the base type.
            </summary>
            <seealso cref="P:Core.TypeCast.Base.Converter.BaseType"/>
        </member>
        <member name="P:Core.TypeCast.ConverterMethodAttribute.LoadOnDemand">
            <summary>
            Gets a value indicating whether the <see cref="T:Core.TypeCast.Converter`2"/> Converter is supposed to be loaded in the <see cref="T:Core.TypeCast.ConverterCollection"/> upon first use.
            </summary>
            <example> **Example:**  A Converter `StringToDNA ` is allowed to be initialized by the <see cref="T:Core.TypeCast.ConverterMethodAttribute"/> 
            <code>```cs
                [Converter(loadOnDemand: false, nameSpace: nameof(Program.BioCode.DNA))]
                internal class StringToDNA {
                    ... 
                    // Constructor with dependency injection
                    public StringToDNA(IConverterCollection collection) 
                    { 
                        ... collection.Add((Func&lt;string, DNA>)this.Convert); ...
                    }
                    // method added explicitly by the constructor supporting converter-dependency-injection
                    // Note: It is recommended to derive the class `StringToDNA`  from `ConverterCollectionDependency`
                    public object Convert(object valueIn)
                    { 
                        ... 
                    }
                    // method loaded automatically, through attribution
                    [Converter(loadOnDemand: true, nameSpace: nameof(Program.NameSpace))]
                    public StringToDNA(IConverterCollection collection, bool storeRNA = false)
                    { 
                        ... 
                    }
                    ...
                }
                ...
            ```</code>
            </example>
        </member>
        <member name="P:Core.TypeCast.ConverterMethodAttribute.IsStatic">
            <summary>
            Gets a value indicating whether the method is invoked with `this` set to null (`true`) or with an instance reference (`false`). Default is `true`.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterMethodAttribute.NameSpace">
            <summary>
            Gets the <see cref="P:System.Type.Namespace"/> or an empty string if no <see cref="P:Core.TypeCast.ConverterMethodAttribute.NameSpace"/> is set.
            </summary>
            <example> **Example:**  A Converter `StringToDNA` is added to the collection namespace of the main `Program` class
            <code>
            ```cs
                [Converter(nameSpace: nameof(Program.NameSpace))]
                internal class StringToDNA
                {   
                    ...
                    public StringToDNA(IConverterCollection collection,  storeRNA = false)
                    { 
                        ... 
                    }
                    ...
                }
                ...
            ```</code>
            </example>
            <remarks>The namespace is used for filtering and grouping of <see cref="N:Core.TypeCast.Converters"/></remarks>
        </member>
        <member name="M:Core.TypeCast.ConverterMethodAttribute.ToString">
            <summary>
            A string representation of the current attribute.
            </summary>
            <returns>
            Returns a <see cref="T:System.String"/> representation of the fields in <see cref="T:Core.TypeCast.ConverterMethodAttribute"/>.
            </returns>
        </member>
        <member name="T:Core.TypeCast.ConverterCollectionSettings">
            <summary>
            The settings for the <see cref="T:Core.TypeCast.ConverterCollection"/>.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionSettings.converterDefaultWrapperOrException">
            <summary>
            If to use the converter-default wrapper or throw an exception.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionSettings.useFunctionDefaultWrapper">
            <summary>
            If to use the function-default wrapper.
            </summary>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionSettings.#ctor(System.Globalization.NumberFormatInfo,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> class.
            </summary>
            <param name="defaultValueAnyType">Set to `true` if any argument type is allowed. If set to `false` <see cref="!:ObjectExtension.ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/> cannot be used.</param>
            <param name="useFunctionDefaultWrapper">
            Whether to use a function default wrapper if the <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/> is `null`, yet required for <see cref="M:Core.TypeCast.Base.Converter.Convert(System.Object,System.Object)"/>.
            </param>
            <param name="numberFormat">
            The number format used for the conversion functions within the <see cref="T:Core.TypeCast.ConverterCollection"/> instance.
            </param>
            <param name="converterMissingException">  Whether to throw a converter missing exception.  </param>
            <param name="allowGenericTypes">Whether to allow generic types as source or target types of converters</param>
            <param name="converterDefaultWrapperOrException">
            Whether to use a default-value wrapper if one is required or throw a default-function missing exception.
            </param>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionSettings.DefaultNumberFormat">
            <summary>
            Gets or sets the default number format.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionSettings.AllowGenericTypes">
            <summary>
            Gets or sets whether to throw an <see cref="T:Core.TypeCast.ConverterException"/> if generic types are passed as the source our target <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionSettings.BoundedCapacity">
            <summary>
            Gets or sets the bounded capacity of <see cref="!:BlockingCollection&lt;Converter&gt;"/> instance in <see cref="T:Core.TypeCast.ConverterCollection"/>, 
            which limit the collection size of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> to a specific number of items at any given time.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionSettings.ConverterDefaultWrapperOrException">
            <summary>
            Gets or sets a value indicating whether to use a default-value wrapper if no default-function is set or throw a default-function is missing exception.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionSettings.ConverterMissingException">
            <summary>
            Gets or sets a value indicating whether to throw a default-function is missing exception.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionSettings.DefaultValueAnyType">
            <summary>
            Gets or sets a value indicating whether the second argument of <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/> is <see cref="T:System.Type"/>-checked to 
            enforce type-equality of the argument/default-value with the return Type of the Function
            </summary>
            <remarks>Sets the <see cref="P:Core.TypeCast.Base.Converter.DefaultValueAnyType"/> auto-property upon adding a <see cref="T:Core.TypeCast.Base.Converter"/> instance 
            to the <see cref="T:Core.TypeCast.ConverterCollection"/>. However if the value changed whilst adding converters, only instances added after the value change will be affected.</remarks>
            <seealso cref="P:Core.TypeCast.Base.Converter.DefaultValueAnyType"/>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionSettings.NumberFormat">
            <summary>
            Gets or sets the number format used by default for <see cref="T:Core.TypeCast.Base.Converter"/> instances.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionSettings.UseFunctionDefaultWrapper">
            <summary>
            Gets or sets a value indicating whether use default-value function-wrapper.
            </summary>
        </member>
        <member name="T:Core.TypeCast.ConverterCollectionException">
            <summary>
                The Exception-type which is raised exclusively by the <see cref="!:Converter&lt;T&gt;" /> Library
            </summary>
            <seealso cref="T:Core.TypeCast.ConverterCollectionCause" />
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionException.#ctor(Core.TypeCast.ConverterCollectionCause,System.String)">
            <summary>
                Initializes a new instance of the  <see cref="T:Core.TypeCast.ConverterCollectionException" /> class. Requires a
                <see cref="T:Core.TypeCast.ConverterCollectionCause" /> and optional user <paramref name="message" />.
            </summary>
            <param name="cause">The coded reason for the Exception</param>
            <param name="message">
                The message for the Exception.  If left empty, the description of the cause will be used as
                exception message
            </param>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionException.#ctor(Core.TypeCast.ConverterCollectionCause,System.Exception)">
            <summary>
                Initializes a new instance of the  <see cref="T:Core.TypeCast.ConverterCollectionException" /> class. Requires a
                <see cref="T:Core.TypeCast.ConverterCollectionCause" /> and <paramref name="innerException" /> message
            </summary>
            <param name="cause">The coded reason for the Exception</param>
            <param name="innerException">The wrapped exception within the <see cref="T:Core.TypeCast.ConverterCollectionException" /></param>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionException.#ctor(Core.TypeCast.ConverterCollectionCause,System.Exception,System.String)">
            <summary>
                Initializes a new instance of the  <see cref="T:Core.TypeCast.ConverterCollectionException" /> class. Requires a
                <see cref="T:Core.TypeCast.ConverterCollectionCause" /> an <paramref name="innerException" /> and an exception <paramref name="message" />
            </summary>
            <param name="cause">The coded reason for the Exception of the value <see cref="T:Core.TypeCast.ConverterCollectionCause" /></param>
            <param name="innerException">The wrapped exception within the <see cref="T:Core.TypeCast.ConverterCollectionException" /></param>
            <param name="message">The <paramref name="message" /> for the Exception</param>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionException.Cause">
            <summary>
                Gets or sets the exception's <see cref="T:Core.TypeCast.ConverterCollectionCause" />, which is set through the parameterized exception constructor
                <see cref="M:Core.TypeCast.ConverterCollectionException.#ctor(Core.TypeCast.ConverterCollectionCause,System.String)" />
            </summary>
            <returns>The enumeration value for the raised Exception of the type <see cref="T:Core.TypeCast.ConverterCollectionCause" /></returns>
            <remarks>To get a detailed description of the value, use <see cref="M:Core.Extensions.EnumExtension.GetDescription(System.Enum,System.String)" /></remarks>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionException.GetMessage">
            <summary>
                Override this method for custom formatting of the unformatted exception <see cref="P:System.Exception.Message" />
            </summary>
            <returns>The string containing the formatted exception message</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterCollectionException.Message">
            <summary>
                Override this method for custom formatting of the unformatted exception <see cref="P:System.Exception.Message" />
            </summary>
            <returns>The string containing the formatted exception message</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterCollectionException.ToString">
            <summary>
            A string representation of the current exception.
            </summary>
            <returns>
            Returns a <see cref="T:System.String"/> representation of <see cref="M:Core.TypeCast.ConverterCollectionException.GetMessage"/> concatenated to the underlying <see cref="M:System.Exception.ToString"/> method.
            </returns>
        </member>
        <member name="T:Core.TypeCast.Converters.ConverterDefaults">
            <summary>
            Converts between <see cref="T:System.Object"/> and the most common System types in the <see cref="N:System"/> namespace. 
            </summary>
            <remarks>
            The reverse, converting from common <see cref="N:System"/> Types to <see cref="T:System.Object"/> is not sensible as a simple boxing operation suffices.
            </remarks>
        </member>
        <member name="F:Core.TypeCast.Converters.ConverterDefaults.self">
            <summary>
            The <see cref="T:System.Type"/> of the own custom converter class
            </summary>
            <remarks>for caching purposes</remarks>
        </member>
        <member name="M:Core.TypeCast.Converters.ConverterDefaults.#ctor(Core.TypeCast.IConverterCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converters.ConverterDefaults"/> class, and adds converters for the most common types of the <see cref="N:System"/> namespace. 
            </summary>
        </member>
        <member name="P:Core.TypeCast.Converters.ConverterDefaults.NumberFormat">
            <summary>
            Gets or sets the Converters <see cref="T:System.Globalization.NumberFormatInfo"/>, which is copied from <see cref="P:Core.TypeCast.ConverterCollectionSettings.NumberFormat"/> upon 
            creating an new instance of <see cref="T:Core.TypeCast.Converters.ConverterDefaults"/> 
            </summary>
        </member>
        <member name="M:Core.TypeCast.Converters.ConverterDefaults.AddObjectConverter(Core.TypeCast.IConverterCollection)">
            <summary>
            The converters to convert from a boxed <see cref="T:System.Object"/> value to Types of the Common C# language <see cref="N:System"/>
            </summary>
            <param name="collection">The <see cref="T:Core.TypeCast.IConverterCollection"/> collection instance to which the converters are added</param>
            <seealso cref="!:Core.TypeCast.Test"/>
        </member>
        <member name="T:Core.TypeCast.Converter`3">
            <summary>
            The specific, strictly-typed converter class for type transformations and complex conversions.
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TArg">The Argument <see cref="T:System.Type"/> for generic converters using see <see cref="!:ObjectExtension.ConvertTo&lt;TIn, TOut&gt;(TIn, object)"/>. 
            In <see cref="T:Core.TypeCast.Converter`2"/> <typeparamref name="TArg"/> is set to <see cref="T:System.Object"/></typeparam>
        </member>
        <member name="M:Core.TypeCast.Converter`3.#ctor(System.Func{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converter`3"/> class.
            </summary>
            <param name="converter"> The converter function. <seealso cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws a <see cref="T:Core.TypeCast.ConverterException"/> caused by <see cref="F:Core.TypeCast.ConverterCause.ConverterArgumentNull"/>
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`3.#ctor(System.Func{`0,`1,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converter`3"/> class.
            </summary>
            <param name="converterDefault"> The converter default function which takes a default-value parameter as the second argument  <seealso cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/>
             wherein <typeparamref name="TIn"/> is the source / from <see cref="T:System.Type"/>from which to <see cref="M:Core.TypeCast.Converter`3.Convert(System.Object,System.Object)"/>, and 
            <typeparamref name="TOut"/> is the target / to <see cref="T:System.Type"/> to which to <see cref="M:Core.TypeCast.Converter`3.Convert(System.Object,System.Object)"/>
            </param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws a <see cref="T:Core.TypeCast.ConverterException"/> caused by <see cref="F:Core.TypeCast.ConverterCause.ConverterArgumentNull"/>
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`3.#ctor(System.Func{`0,`2,`1},System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converter`3"/> class.
            </summary>
            <param name="converterAny"> The convert function which takes a model parameter as the second argument  <seealso cref="!:Converter.ConverterDefaultAnyTypeFunc"/>
             wherein <typeparamref name="TIn"/> is the source / from <see cref="T:System.Type"/>from which to <see cref="M:Core.TypeCast.Converter`3.Convert(System.Object,System.Object)"/>, <typeparamref name="TArg"/> is the argument type, 
             ideally a converter-model (see the code-examples) and <typeparamref name="TOut"/> is the target / to <see cref="T:System.Type"/> to which to <see cref="M:Core.TypeCast.Converter`3.Convert(System.Object,System.Object)"/>
            </param>
            <param name="argument">The optional <seealso cref="T:System.Type"/> of the argument passed to <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/>.</param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws a <see cref="T:Core.TypeCast.ConverterException"/> caused by <see cref="F:Core.TypeCast.ConverterCause.ConverterArgumentNull"/>
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`3.#ctor(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.Converter`3"/> class.
            </summary>
            <param name="converterDefaultAnyType"> The convert function which takes a model parameter as the second argument  <seealso cref="!:Converter.ConverterDefaultAnyTypeFunc"/>
             wherein <typeparamref name="TIn"/> is the source / from <see cref="T:System.Type"/>from which to <see cref="M:Core.TypeCast.Converter`3.Convert(System.Object,System.Object)"/>, <typeparamref name="TArg"/> is the argument type, 
             ideally a converter-model (see the code-examples) and <typeparamref name="TOut"/> is the target / to <see cref="T:System.Type"/> to which to <see cref="M:Core.TypeCast.Converter`3.Convert(System.Object,System.Object)"/>
            </param>
            <param name="argument">The optional <seealso cref="T:System.Type"/> of the argument passed to <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/>.</param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws a <see cref="T:Core.TypeCast.ConverterException"/> caused by <see cref="F:Core.TypeCast.ConverterCause.ConverterArgumentNull"/>
            </exception>
        </member>
        <member name="P:Core.TypeCast.Converter`3.ConverterAnyFunc">
            <summary>
            Gets or sets the converter default function with any arbitrary second argument-type
            </summary>
            <seealso cref="P:Core.TypeCast.ConverterCollectionSettings.DefaultValueAnyType"/>
            <seealso cref="P:Core.TypeCast.Base.Converter.DefaultValueAnyType"/>
        </member>
        <member name="P:Core.TypeCast.Converter`3.ConverterDefaultFunc">
            <summary>
            Gets or sets the converter default function
            </summary>
        </member>
        <member name="P:Core.TypeCast.Converter`3.ConverterFunc">
            <summary>
            Gets or sets the converter function
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
        </member>
        <member name="M:Core.TypeCast.Converter`3.Convert(System.Object,System.Object)">
            <summary> The <see cref="T:Core.TypeCast.Base.Converter"/> convert function as part of the <see cref="T:Core.TypeCast.IConverter"/> interface support. </summary>
            <param name="value">The value of <see cref="T:System.Type"/> <see cref="!:TIn"/> to be converted.</param>
            <param name="defaultValue">The optional default value of <see cref="T:System.Type"/> <see cref="!:TOut"/>to be passed if the conversion fails or is `null`.</param>
            <returns>The converted value as a boxed <see cref="T:System.Object"/>.</returns>
            <remarks>The actual implementation and use of the second parameter lies solely within the scope of the programmer implementing the converter logic</remarks>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws an exception if the argument or converter function is null, or if the argument types mismatch
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`3.ConvertDefault(System.Object@,System.Object@)">
            <summary> An helper function for the <see cref="M:Core.TypeCast.Base.Converter.Convert(System.Object,System.Object)"/> function. </summary>
            <param name="value">The value of <see cref="T:System.Type"/> <see cref="!:TIn"/> to be converted.</param>
            <param name="defaultValue">The default value of <see cref="T:System.Type"/> <see cref="!:TOut"/>to be passed if the conversion fails or is `null`.</param>
            <returns>The converted value as a boxed <see cref="T:System.Object"/>.</returns>
            <remarks>The actual implementation and use of the second parameter lies solely within the scope of the programmer implementing the converter logic</remarks>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws an exception if the argument or converter function is null, or if the argument types mismatch
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`3.Convert(`0,`1)">
            <summary> The converter function that needs to be overwritten as part of the <see cref="T:Core.TypeCast.IConverter"/> interface support. </summary>
            <param name="valueTyped">The value of <see cref="T:System.Type"/> <see cref="!:TIn"/> to be converted.</param>
            <param name="defaultValueTyped">The optional default value of <see cref="T:System.Type"/> <see cref="!:TOut"/>to be passed if the conversion fails or is `null`.</param>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <returns>The value converted to <see cref="T:System.Type"/> of <see cref="!:TOut"/> </returns>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of <see cref="F:Core.TypeCast.ConverterCause.ConverterNotImplemented"/> if the parent class
             does not implement `public override TOut ` <see cref="M:Core.TypeCast.Converter`3.Convert(System.Object,System.Object)"/>
            </exception>
        </member>
        <member name="M:Core.TypeCast.Converter`3.CheckConvertTypes(System.Object,System.Object)">
            <summary> Checks the types being in the correct source and target format, if not exceptions are thrown. </summary>
            <param name="value">The value to be converted.</param>
            <param name="defaultValue">The optional default value to be passed if the conversion fails or is `null`.</param>
            <exception cref="T:Core.TypeCast.ConverterException">Throws exceptions based on mismatching types or null references</exception>
        </member>
        <member name="T:Core.TypeCast.ConverterParameters">
            <summary>
            Container with sequentially assigned type-parameters of a strictly typed Converter-Function, in the sequence of Types for: In, Out, Argument
            </summary>
        </member>
        <member name="M:Core.TypeCast.ConverterParameters.#ctor(System.Reflection.ParameterInfo,System.Reflection.ParameterInfo[])">
            <summary>
            Creates a new instance of <see cref="T:Core.TypeCast.ConverterParameters"/>
            </summary>
            <param name="parameters">A sequential list of function parameters in order of In, Out, Argument</param>
            <example>
            <code>
            ```cs
                Func&lt;bool> method = () => true;
                var methodInfo = method.Method;
                var parameterInfos = methodInfo.GetParameters();
                var parameterTypes = new ConverterParameters(methodInfo.ReturnParameter, parameterInfos);
                Console.WriteLine( parameterTypes );
            ```
            </code>
            </example>
            <seealso cref="T:Core.TypeCast.Converter`3"/>
        </member>
        <member name="M:Core.TypeCast.ConverterParameters.#ctor(System.Reflection.ParameterInfo[])">
            <summary>
            Creates a new instance of <see cref="T:Core.TypeCast.ConverterParameters"/>
            </summary>
            <param name="parameters">A sequential list of function parameters in order of In, Out, Argument</param>
            <remarks>
            In preparation of creating strongly typed standard containers of <see cref="T:Core.TypeCast.Converter`3"/>
            the argument type is assigned to the Out-Type, when no second parameter type is provided i.e. <code>`Count == 2`</code>  
            </remarks>
            <seealso cref="T:Core.TypeCast.Converter`3"/>
        </member>
        <member name="M:Core.TypeCast.ConverterParameters.ToArray">
            <summary>
            Returns an Array of <see cref="T:System.Type"/> in the order of the Converter generic arguments <seealso cref="T:Core.TypeCast.Converter`3"/>
            </summary>
            <returns>an array containing <paramref name="In"/>, <paramref name="Out"/>, <paramref name="Arg"/></returns>
        </member>
        <member name="M:Core.TypeCast.ConverterParameters.ToString">
            <summary>
            Returns a string representation of the <see cref="!:struct"/> contents
            </summary>
            <returns></returns>
        </member>
        <member name="T:Core.TypeCast.ConverterExtension">
            <summary>
            The <see cref="T:Core.TypeCast.Base.Converter"/> extension methods
            </summary>
        </member>
        <member name="M:Core.TypeCast.ConverterExtension.FunctionDefaultWrapper``2(Core.TypeCast.Base.Converter)">
            <summary>
            Wraps the converter function <see cref="P:Core.TypeCast.Base.Converter.Function"/> to allow passing of a default-value, which is returned when the conversion yields `null`
            </summary>
            <typeparam name="TIn">The source / from <see cref="T:System.Type"/>from which to convert</typeparam>
            <typeparam name="TOut">The target / to <see cref="T:System.Type"/> to which to converter</typeparam>
            <param name="self">the current instance of the <see cref="T:Core.TypeCast.Base.Converter"/></param>
            <returns>Returns a function wrapper which takes a default-value of type <typeparamref name="TOut"/> as a second parameter </returns>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException"/>if the conversion fails</exception>
            <example>  **Example:** Get a default-value accepting wrapper function from a converter and invoke it.
            <code>
            ```cs
                var converter = new Converter&lt;int?, float>((int? a) => {
                           return (float)(a ?? 0);
                });
                Func&lt;int?, float, float> intNullToSingleWithDefaultValue = converter.FunctionDefaultWrapper&lt;int?, float>();
                var singleValue = intNullToSingleWithDefaultValue(new int?(5), 5.0f);
            ```
            </code></example>
            
            <remarks>Use <see cref="T:Core.TypeCast.Converter`2"/> instead for the typed converter implementation.</remarks>
        </member>
        <member name="M:Core.TypeCast.ConverterExtension.FunctionDefaultWrapper``2(Core.TypeCast.Converter{``0,``1})">
            <summary>
            Wraps the converter function <see cref="P:Core.TypeCast.Base.Converter.Function"/> to allow passing of a default-value, which is returned when the conversion yields `null`
            </summary>
            <typeparam name="TIn">The source / from <see cref="T:System.Type"/>from which to convert</typeparam>
            <typeparam name="TOut">The target / to <see cref="T:System.Type"/> to which to converter</typeparam>
            <param name="self">the current instance of the <see cref="T:Core.TypeCast.Base.Converter"/></param>
            <returns>Returns a function wrapper which takes a default-value of type <typeparamref name="TOut"/> as a second parameter </returns>
            <exception cref="T:Core.TypeCast.ConverterException">Throws an exception of type <see cref="T:Core.TypeCast.ConverterException"/>if the conversion fails</exception>
            <remarks>Use <see cref="T:Core.TypeCast.Base.Converter"/> instead for the untyped base-converter implementation.</remarks>
            See <seealso cref="M:Core.TypeCast.ConverterExtension.FunctionDefaultWrapper``2(Core.TypeCast.Base.Converter)"/> for the logical implementation
        </member>
        <member name="M:Core.TypeCast.ConverterExtension.MergeStandard(Core.TypeCast.Base.Converter,Core.TypeCast.Base.Converter)">
            <summary>
            If possible, the method merges a second Converter instance <paramref name="converter"/> into the own instance, and returns <see cref="T:System.Boolean"/> `true` if successful, else `false`
            </summary>
            <param name="self">the current instance of the <see cref="T:Core.TypeCast.Base.Converter"/></param>
            <param name="converter">the other converter instance of which to look up the function and assign it to the own instance</param>
            <exception cref="T:Core.TypeCast.ConverterCollectionException">Raises an exception if both converters have either their <see cref="P:Core.TypeCast.Base.Converter.Function"/> or 
            <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/> assigned, with the cause: <see cref="F:Core.TypeCast.ConverterCollectionCause.ConverterExists"/></exception>
            <returns>Returns <see cref="T:System.Boolean"/> `true` if successful in merging, else `false`.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterExtension.SetCollectionDefaults(Core.TypeCast.Base.Converter,Core.TypeCast.ConverterCollection)">
            <summary>
            Sets default settings derived from a <see cref="T:Core.TypeCast.ConverterCollection"/> instance whose reference is acquired via <see cref="P:Core.TypeCast.Base.Converter.Collection"/>
            </summary>
            <param name="self">the current instance of the <see cref="T:Core.TypeCast.Base.Converter"/></param>
            <param name="collection">An instance reference to a <see cref="T:Core.TypeCast.ConverterCollection"/></param>
            <returns><see cref="T:System.Boolean"/> `true` if successful, `false` if <see cref="P:Core.TypeCast.Base.Converter.Collection"/> is null.</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterExtension.SetBaseType(Core.TypeCast.Base.Converter,System.Type)">
            <summary>
            Tries to set the <see cref="P:Core.TypeCast.Base.Converter.BaseType"/> as the declaring-type (<see cref="P:System.Type.DeclaringType"/> of the underlying converter-function.
            </summary>
            <param name="self">the current instance of the <see cref="T:Core.TypeCast.Base.Converter"/></param>
            <param name="baseType">The declaring-type (<see cref="P:System.Type.DeclaringType"/> of the underlying converter-function.</param>
        </member>
        <member name="M:Core.TypeCast.ConverterExtension.WithSameFromType(Core.TypeCast.Base.Converter)">
            <summary>
            Looks up converters with the same <see cref="P:Core.TypeCast.Base.Converter.From"/> Type
            </summary>
            <param name="self"></param>
            <returns>Returns an <see cref="T:System.Linq.IQueryable`1"/> of converters with the same <see cref="P:Core.TypeCast.Base.Converter.To"/> Type</returns>
        </member>
        <member name="M:Core.TypeCast.ConverterExtension.WithSameToType(Core.TypeCast.Base.Converter)">
            <summary>
            Looks up converters with the same <see cref="P:Core.TypeCast.Base.Converter.To"/> Type
            </summary>
            <param name="self">the current instance of the <see cref="T:Core.TypeCast.Base.Converter"/></param>
            <returns>Returns an <see cref="T:System.Linq.IQueryable`1"/> of converters with the same <see cref="P:Core.TypeCast.Base.Converter.To"/> Type</returns>
        </member>
        <member name="T:Core.TypeCast.IRepositoryEnumerable`1">
            <summary>The generic repository interface with one lookup identifier</summary>
            <remarks>Implemented by any instantiable object which can provide data by passing one Identifier to facilitate lookup</remarks>
            <example><code>
            ```cs
                ConverterCollection.CurrentInstance.Add( (int[] a, IModelWeather model) =>  { 
                    ...repo... 
                });
                IRepositoryEnumerable&lt;IModelWeather> repositoryQuery = new []{40420,52000,80801,20030}
                                                                            .ConvertTo&lt;IRepositoryEnumerable&lt;IModelWeather>>( modelInstance );
                foreach( var item in repositoryQuery)
                {
                    ...
                }
            ```
            </code></example>
        </member>
        <member name="T:Core.TypeCast.IRepositoryEnumerable`2">
            <summary>The generic repository interface with one lookup identifier, and a strict entity return type of <typeparamref name="TOut"/></summary>
            <typeparam name="TId1">The <see cref="T:System.Type"/> of the lookup identifier <paramref name="id1"/></typeparam>
            <typeparam name="TOut">The <see cref="T:System.Type"/> of the entity returned from the repository method <see cref="!:Get(TId1)"/></typeparam>
            <remarks>Implemented by any instantiable object which can provide data by passing one Identifier to facilitate lookup</remarks>
        </member>
        <member name="T:Core.TypeCast.IRepositoryEnumerable`3">
            <summary>The generic repository interface with twp lookup identifiers, and a strict entity return type of <typeparamref name="TOut"/></summary>
            <typeparam name="TId1">The <see cref="T:System.Type"/> of the lookup identifier <paramref name="id1"/></typeparam>
            <typeparam name="TId1">The <see cref="T:System.Type"/> of the lookup identifier <paramref name="id2"/></typeparam>
            <typeparam name="TOut">The <see cref="T:System.Type"/> of the entity returned from the repository method <see cref="!:Get(TId1)"/></typeparam>
            <remarks>Implemented by any instantiable object which can provide data by passing two Identifiers to facilitate lookup</remarks>
        </member>
        <member name="T:Core.TypeCast.IRepository">
            <summary>The base repository interface</summary>
            <remarks>Implemented by any instantiable object which can provide data by passing an Identifier to facilitate lookup</remarks>
        </member>
        <member name="M:Core.TypeCast.IRepository.Get(System.Object)">
            <summary>
            Gets a single entity or a collection of entities, implementing an <see cref="T:System.Collections.IEnumerable"/> which correspond to the identifier <paramref name="id"/>.
            </summary>
            <param name="id"> The identifier for facilitating lookup of one or several entities</param>
            <returns>An <see cref="T:System.Object"/> comprising one or several entities which correspond to the identifier <paramref name="id"/>.  </returns>
        </member>
        <member name="T:Core.TypeCast.IRepository`1">
            <summary>The generic repository interface with one lookup identifier</summary>
            <remarks>Implemented by any instantiable object which can provide data by passing one Identifier to facilitate lookup</remarks>
        </member>
        <member name="M:Core.TypeCast.IRepository`1.Get(System.Object)">
            <summary>
            Gets a single entity or a collection of entities, implementing an <see cref="T:System.Collections.IEnumerable"/> which correspond to the identifier <paramref name="id"/>.
            </summary>
            <param name="id"> The identifier for facilitating lookup of one or several entities</param>
            <returns>An <see cref="T:System.Object"/> comprising one or several entities which correspond to the identifier <paramref name="id"/>.  </returns>
        </member>
        <member name="T:Core.TypeCast.IRepository`2">
            <summary>The generic repository interface with one lookup identifier, and a strict entity return type of <typeparamref name="TOut"/></summary>
            <typeparam name="TId1">The <see cref="T:System.Type"/> of the lookup identifier <paramref name="id1"/></typeparam>
            <typeparam name="TOut">The <see cref="T:System.Type"/> of the entity returned from the repository method <see cref="M:Core.TypeCast.IRepository`2.Get(`0)"/></typeparam>
            <remarks>Implemented by any instantiable object which can provide data by passing one Identifier to facilitate lookup</remarks>
        </member>
        <member name="T:Core.TypeCast.IRepository`3">
            <summary>The generic repository interface with twp lookup identifiers, and a strict entity return type of <typeparamref name="TOut"/></summary>
            <typeparam name="TId1">The <see cref="T:System.Type"/> of the lookup identifier <paramref name="id1"/></typeparam>
            <typeparam name="TId1">The <see cref="T:System.Type"/> of the lookup identifier <paramref name="id2"/></typeparam>
            <typeparam name="TOut">The <see cref="T:System.Type"/> of the entity returned from the repository method <see cref="!:Get(TId1)"/></typeparam>
            <remarks>Implemented by any instantiable object which can provide data by passing two Identifiers to facilitate lookup</remarks>
        </member>
        <member name="M:Core.TypeCast.IRepository`3.Get(`0,`1)">
            <summary>The initialize method.</summary>
            <param name="id1">The argument value of the lookup identifier</param>
            <param name="id2">The argument value of the lookup identifier</param>
            <returns>A strict entity return type of <typeparamref name="TOut"/> which may be a single entity or collection thereof, implementing <see cref="T:System.Collections.IEnumerable"/>
            </returns>
        </member>
        <member name="T:Core.TypeCast.ConverterCollectionCause">
            <summary>
            Contains the reasons for a <see cref="T:Core.TypeCast.ConverterCollectionException"/> to be raised.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.None">
            <summary>
            Indicates the default or unspecified value
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.Unknown">
            <summary>
            Indicates an unknown or undefined flag
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.Default">
            <summary>
            Indicates a default or normal flag
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.InternalError">
            <summary>
            Indicates an internal error state that may be specified further in the <see cref="P:System.Exception.InnerException"/> property
            </summary>
            <remarks>Can be raised when the Converter's constructor must be explicitly called with parameters</remarks>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.AddFailed">
            <summary>
            The converter could not be added to the <see cref="T:Core.TypeCast.ConverterCollection"/>
            </summary>
            <seealso cref="M:Core.TypeCast.ConverterCollection.Add``2(System.Func{``0,``1},System.Type,System.Threading.CancellationToken)"/>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.CollectionIsNull">
            <summary>
            Indicates a null reference for the collection argument
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.ConverterExists">
            <summary>
            Indicates that the <see cref="T:Core.TypeCast.Converter`2"/>, defined by the Input and Output conversion Types `TIn --> TOut` already exists
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.ConverterArgumentNull">
            <summary>
            Indicates that the <see cref="T:Core.TypeCast.Converter`2"/> or an passed argument to a Converter method is `null`
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.ConverterArgumentWrongType">
            <summary>
            Indicates that a <see cref="T:Core.TypeCast.ConverterCollection"/> method got passed an argument of a <see cref="T:System.Type"/>`T` that does not match TIn or TOut respectively
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.ConverterClassExists">
            <summary>
            The custom converter / conversion-related class has already been instantiated and added to the to the <see cref="T:Core.TypeCast.ConverterCollection"/> 
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.InstanceRequiresParameters">
            <summary>
            Indicates that the constructor the <see cref="T:Core.TypeCast.ConverterCollection"/> class requires parameters for proper instancing, yet was invoked without parameters.
            </summary>
            <remarks>User-thrown exception in the custom parameter-less constructor of the logical Converter class</remarks>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.ConverterFunctionsNull">
            <summary>
            Indicates that the <see cref="P:Core.TypeCast.Base.Converter.Function"/> property and <see cref="P:Core.TypeCast.Base.Converter.FunctionDefault"/> is not set to a <see cref="T:System.Delegate"/> and `null`
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCollectionCause.AddFailedConverterExists">
            <para>Flag Combinations</para>
            <para></para>
            <summary>
            The converter could not be added to the <see cref="T:Core.TypeCast.ConverterCollection"/> because another converter for the specified input/output types already exists
            </summary>
        </member>
        <member name="T:Core.TypeCast.ConverterCause">
            <summary>
            Contains the reasons for a <see cref="T:Core.TypeCast.ConverterException"/> to be raised.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.None">
            <summary>
            Indicates the default or unspecified value
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.Unknown">
            <summary>
            Indicates an unknown or undefined flag
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.Default">
            <summary>
            Indicates a default or normal flag
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterFunctionNull">
            <summary>
            Indicates that the <see cref="P:Core.TypeCast.Base.Converter.Function"/> property is not set and `null`
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterArgumentNull">
            <summary>
            Indicates that the <see cref="T:Core.TypeCast.Converter`2"/> or an passed argument to a Converter method is `null`
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterArgumentGenericType">
            <summary>
            Indicates a generic input type <see cref="P:Core.TypeCast.Base.Converter.From"/> was passed, whilst being explicitly disallowed in the <see cref="T:Core.TypeCast.ConverterCollectionSettings"/> instance
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterArgumentWrongType">
            <summary>
            Indicates that a <see cref="T:Core.TypeCast.Converter`2"/> method got passed an argument of a <see cref="T:System.Type"/>`T` that does not match TIn or TOut respectively
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterExists">
            <summary>
            Indicates that the <see cref="T:Core.TypeCast.Converter`2"/>, defined by the Input and Output conversion Types `TIn --> TOut` already exists
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConvertFailed">
            <summary>
            Indicates that the <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/> method failed near or at the custom convert Function invocation 
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterWrapperError">
            <summary>
            Indicates that the custom converter function wrapper yielded an error
            </summary>
            <seealso cref="M:Core.TypeCast.ConverterExtension.FunctionDefaultWrapper``2(Core.TypeCast.Base.Converter)"/>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.InternalError">
            <summary>
            Indicates an internal error state that may be specified further in the <see cref="P:System.Exception.InnerException"/> property
            </summary>
            <remarks>Can be raised when the Converter's constructor must be explicitly called with parameters</remarks>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConstructorInjectionNull">
            <summary>
            Dependency Injection failed due to a `null` reference
            </summary>
            <remarks><para>Indicates that a conversion related class constructor was injected with an argument that is null</para></remarks>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed">
            <summary>
            The <see cref="T:Core.TypeCast.Base.Converter"/> could not be added to the <see cref="T:Core.TypeCast.ConverterCollection"/>
            </summary>
            <remarks>The <see cref="T:Core.TypeCast.Base.Converter"/> instance was not added to the <see cref="T:System.Collections.Concurrent.BlockingCollection`1"/> <see cref="P:Core.TypeCast.ConverterCollection.Items"/></remarks>
            <seealso cref="M:Core.TypeCast.ConverterCollection.Add``2(System.Func{``0,``1},System.Type,System.Threading.CancellationToken)"/>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.InstanceRequiresParameters">
            <summary>
            Indicates that the constructor of a parent <see cref="T:Core.TypeCast.Converter`2"/> class `T` requires parameters for proper instancing, yet was invoked parameter-less.
            </summary>
            <remarks>User-thrown exception in the custom parameter-less constructor of the logical Converter class</remarks>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterNotImplemented">
            <summary>
            Indicates that a method in a converter or conversion-related class instance does not possess a logical implementation.
            </summary>
            <remarks>Make sure methods marked as virtual are overwritten.</remarks>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterTypeInIsExplicitObject">
            <summary>
            Indicates that the conversion source type is set to object, which is not sensible. Omit setting both target type parameters instead
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterArgumentDelegateTooManyParameters">
            <summary>
            Indicates that passed converter function takes too many parameters. A maximum of two is permitted.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterArgumentDelegateNoParameters">
            <summary>
            Indicates that the passed converter function takes no parameters. At least one up two a maximum of two is required.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterAutoInitializationFailed">
            <summary>
            Indicates that the reflection of the loading assembly failed, likely due to changes or security fixes for newer portable library class releases
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.TransformRequiresEqualInOutTypes">
            <summary>
            Indicates that the source and target types do not match. If they do not match use other functions instead, like CastTo and ConvertTo.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.InvalidCast">
            <summary>
            Indicates that the cast failed, likely due to a missing converter. These exceptions can be suppressed with a function argument.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.DelegateArgumentWrongType">
            <summary>
            Indicates that the argument types of a given delegate do not match the return type and / or types of the provided parameters.
            </summary>
        </member>
        <member name="F:Core.TypeCast.ConverterCause.ConverterFunctionDefaultNull">
            <para>Flag Combinations</para>
            <para></para>
            <summary>
            Indicates a null-reference for an existing Converter default function
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Core.TypeCast.IConverter" -->
        <member name="M:Core.TypeCast.IConverter.Convert(System.Object,System.Object)">
            <summary>
            The convert method for converting a boxed <see cref="!:value"/> to another boxed value-<see cref="T:System.Object"/>.
            </summary>
            <param name="value">The boxed value of the underlying source-<see cref="T:System.Type"/> which is to be converted to a boxed value of the target-<see cref="T:System.Type"/>.</param>
            <param name="defaultValue"> The default value which may be used by the <see cref="M:Core.TypeCast.IConverter.Convert(System.Object,System.Object)"/>function if the conversion fails or is `null`</param>
            <returns>The boxed <see cref="T:System.Object"/> of the target-type.</returns>
            <remarks>It is not required for a custom converter to support the common <see cref="T:Core.TypeCast.IConverter"/> interface </remarks>
        </member>
        <member name="T:Core.TypeCast.IConverter`2">
            <summary>
            This interface defines strictly the conversion and methods between two specified types. 
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <remarks>It is not necessary for a custom converter implementation to support the generic <see cref="T:Core.TypeCast.IConverter`2"/> interface, but is highly 
            recommended for readability future-proofing, and automatic attribute assignment through <see cref="N:System.Reflection"/>
            </remarks>
            <seealso cref="!:ConverterCollection.GetConverterAttributeFromIConverter(System.Reflection.TypeInfo,Core.TypeCast.ConverterAttribute,bool)"/>
        </member>
        <member name="M:Core.TypeCast.IConverter`2.Convert(`0,`1)">
            <summary>
            The method to converts between two specified types
            </summary>
            <param name="value">The value of the underlying source-<see cref="T:System.Type"/> <typeparamref name="TIn"/> which is to be converted to a value of the 
            target-<see cref="T:System.Type"/> <typeparamref name="TOut"/>.</param>
            <param name="defaultValue"> The default value which may be used by the <see cref="M:Core.TypeCast.IConverter`2.Convert(`0,`1)"/> function if the conversion fails or is `null`</param>
            <returns>Returns destination value type <typeparamref name="TOut"/></returns>
        </member>
        <member name="P:Core.TypeCast.IConverterCollection.AssemblyInitialized">
            <summary>
            Sets the <see cref="T:System.Reflection.Assembly"/> as initialized in <see cref="P:Core.TypeCast.IConverterCollection.AssemblyInitialized"/>
            </summary>
            <param name="type">the <see cref="T:System.Reflection.TypeInfo"/> instance from which to lookup the <see cref="P:System.Reflection.TypeInfo.Assembly"/></param>
            <returns>Returns true if the concurrent dictionary update succeeded</returns>
        </member>
        <member name="P:Core.TypeCast.IConverterCollection.Items">
            <summary>
            The <see cref="T:System.Collections.Concurrent.BlockingCollection`1"/> class provides a thread-safe collection with full support of the Producer-Consumer pattern, 
            to store a collection of <see cref="T:Core.TypeCast.Base.Converter"/> instances.
            </summary>
        </member>
        <member name="P:Core.TypeCast.IConverterCollection.Count">
            <summary>Gets the count of singletons in the list.</summary>
        </member>
        <member name="P:Core.TypeCast.IConverterCollection.Settings">
            <summary>
            The settings for the <see cref="T:Core.TypeCast.ConverterCollection"/>.
            </summary>
        </member>
        <member name="M:Core.TypeCast.IConverterCollection.Add(Core.TypeCast.Base.Converter,System.Type,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/>
            </summary>
            <param name="converter">The <see cref="T:Core.TypeCast.Base.Converter"/> instance to add to the <see cref="P:Core.TypeCast.ConverterCollection.Items"/></param>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</param>
            <param name="allowDisambiguates">Optional <see cref="T:System.Boolean"/> value to indicate whether to allow multiple converters with the 
            same return and parameter <see cref="T:System.Type"/>s in the collection of <see cref="P:Core.TypeCast.IConverterCollection.Items"/>. Only set to `true` for transform functions.</param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterCollectionException">Throws an exception if adding failed</exception>
        </member>
        <member name="M:Core.TypeCast.IConverterCollection.Add``2(System.Func{``0,``1},System.Type,System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="converterAction">A function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.IConverterCollection.Add``3(System.Func{``0,``1},System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TBase">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class</typeparam>
            <param name="converterAction">A function delegate <see cref="T:System.Func`2"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Core.TypeCast.IConverterCollection.Add``3(System.Func{``0,``1,``2},System.Type,System.Threading.CancellationToken)" -->
        <member name="M:Core.TypeCast.IConverterCollection.Add``3(System.Func{``0,``1,``1},System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <typeparam name="TIn">The Source- / From- <see cref="T:System.Type"/>from which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type"/> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)"/></typeparam>
            <param name="converterActionDefault">A function delegate <see cref="T:System.Func`3"/> to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="M:Core.TypeCast.IConverterCollection.Add(System.Object,System.Type,System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <param name="converterDelegate">An optional function delegate to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="baseType">The <see cref="T:System.Type"/> of the declaring and attributed custom converter class, if one exists</param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
        </member>
        <member name="M:Core.TypeCast.IConverterCollection.Add``1(System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates and adds a <see cref="T:Core.TypeCast.Base.Converter"/> instance to the collection of <see cref="P:Core.TypeCast.ConverterCollection.Items"/> using a <see cref="T:System.Delegate"/>
            </summary>
            <param name="converterDelegate">An optional function delegate to use as the <see cref="P:Core.TypeCast.Base.Converter.Function"/></param>
            <param name="cancellationToken">Optional token to propagate notification that operations should be canceled. From <see cref="N:System.Threading.Tasks"/>.</param>
            <returns>Returns a <see cref="T:Core.TypeCast.IConverterCollection"/> for safe, constricted function chaining.</returns>
            <exception cref="T:Core.TypeCast.ConverterException"> Throws a <see cref="F:Core.TypeCast.ConverterCause.ConverterCollectionAddFailed"/> with a wrapped <see cref="P:System.Exception.InnerException"/>
            if an internal error occurred</exception>
        </member>
        <member name="T:Core.TypeCast.IException">
            <summary>
            The common <see cref="T:System.Exception"/>interface.
            </summary>
        </member>
        <member name="M:Core.TypeCast.IException.GetMessage">
            <summary>
            Gets the exception message.
            </summary>
            <returns>The <see cref="T:System.String"/> message containing a <see cref="T:System.String"/> representation of the <see cref="T:System.Exception"/></returns>
        </member>
        <member name="T:Core.TypeCast.IException`1">
            <summary>
            The generic <see cref="T:System.Exception"/>interface.
            </summary>
            <typeparam name="TCause">The custom <see cref="T:System.Enum"/> type containing a coded representation of the exception cause</typeparam>
        </member>
        <member name="P:Core.TypeCast.IException`1.Cause">
            <summary>
            Gets a custom <see cref="T:System.Enum"/> type containing exception causes.
            </summary>
        </member>
        <member name="T:Core.TypeCast.ConverterException">
            <summary>
                The Exception-type which is raised exclusively by the <see cref="T:Core.TypeCast.Converter`2" /> Library
            </summary>
            <seealso cref="T:Core.TypeCast.ConverterCause" />
        </member>
        <member name="M:Core.TypeCast.ConverterException.#ctor(Core.TypeCast.ConverterCause,System.String)">
            <summary>
                Initializes a new instance of the  <see cref="T:Core.TypeCast.ConverterException" /> class. Requires a
                <see cref="T:Core.TypeCast.ConverterCause" /> and optional user <paramref name="message" />.
            </summary>
            <param name="cause">The coded reason for the Exception</param>
            <param name="message">
                The message for the Exception.  If left empty, the description of the cause will be used as
                exception message
            </param>
        </member>
        <member name="M:Core.TypeCast.ConverterException.#ctor(Core.TypeCast.ConverterCause,System.Exception)">
            <summary>
                Initializes a new instance of the  <see cref="T:Core.TypeCast.ConverterException" /> class. Requires a
                <see cref="T:Core.TypeCast.ConverterCause" /> and <paramref name="innerException" /> message
            </summary>
            <param name="cause">The coded reason for the Exception</param>
            <param name="innerException">The wrapped exception within the <see cref="T:Core.TypeCast.ConverterException" /></param>
        </member>
        <member name="M:Core.TypeCast.ConverterException.#ctor(Core.TypeCast.ConverterCause,System.Exception,System.String)">
            <summary>
                Initializes a new instance of the  <see cref="T:Core.TypeCast.ConverterException" /> class. Requires a
                <see cref="T:Core.TypeCast.ConverterCause" /> an <paramref name="innerException" /> and an exception <paramref name="message" />
            </summary>
            <param name="cause">The coded reason for the Exception of the value <see cref="T:Core.TypeCast.ConverterCause" /></param>
            <param name="innerException">The wrapped exception within the <see cref="T:Core.TypeCast.ConverterException" /></param>
            <param name="message">The <paramref name="message" /> for the Exception</param>
        </member>
        <member name="P:Core.TypeCast.ConverterException.Cause">
            <summary>
                Gets or sets the exception's <see cref="T:Core.TypeCast.ConverterCause" />, which is set through the parameterized exception constructor
                <see cref="M:Core.TypeCast.ConverterException.#ctor(Core.TypeCast.ConverterCause,System.String)" />
            </summary>
            <returns>The enumeration value for the raised Exception of the type <see cref="T:Core.TypeCast.ConverterCause" /></returns>
            <remarks>To get a detailed description of the value, use <see cref="M:Core.Extensions.EnumExtension.GetDescription(System.Enum,System.String)" /></remarks>
        </member>
        <member name="M:Core.TypeCast.ConverterException.GetMessage">
            <summary>
                Override this method for custom formatting of the unformatted exception <see cref="P:System.Exception.Message" />
            </summary>
            <returns>The string containing the formatted exception message</returns>
        </member>
        <member name="P:Core.TypeCast.ConverterException.Message">
            <summary>
                Gets the exception message.
            </summary>
        </member>
        <member name="M:Core.TypeCast.ConverterException.ToString">
            <summary>
            A string representation of the current exception.
            </summary>
            <returns>
            Returns a <see cref="T:System.String"/> representation of <see cref="M:Core.TypeCast.ConverterException.GetMessage"/> concatenated to the underlying <see cref="M:System.Exception.ToString"/> method.
            </returns>
        </member>
        <member name="T:Core.TypeCast.ConverterAttribute">
            <summary>
            Use <see cref="T:Core.TypeCast.ConverterAttribute"/> to declare a class as a logical Type Converter. As such the only contingent declaration contract requirement is adherence to 
            implement a public constructor which takes a `IConverterCollection collection` parameter
            </summary>
            <remarks>
            The attribute provides collective initialization through the <see cref="T:Core.TypeCast.ConverterCollection"/> class.
            </remarks>
            <example> **Example:**  
            <code>
            ```cs
                [Converter(loadOnDemand: false, nameSpace: nameof(Program.NameSpace))]
                public class StringToDNA : IConverter, IConverter&lt;string, DNA>{
                    ... 
                    public StringToDNA(IConverterCollection collection){ ... collection.Add((Func&lt;string, DNA>)this.Convert); ...}
                    public object Convert(object valueIn){ ... }
                    public DNA Convert(string valueIn) { ... }
                    [ConverterMethod]
                    public object ToProtein(string valueIn){
                    }
                    ...
                }
            ```
            </code>
            </example>
        </member>
        <member name="M:Core.TypeCast.ConverterAttribute.#ctor(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Core.TypeCast.ConverterAttribute"/> class, to declare a custom <see cref="T:Core.TypeCast.Base.Converter"/>
            </summary>
            <param name="loadOnDemand"> Set to `true` to allow joint initialization by the lazy instancing of the <see cref="T:Core.TypeCast.ConverterCollection"/> <see cref="N:Core.Singleton"/>  </param>
            <param name="nameSpace"> The namespace as a string, ideally set via the <see cref="!:nameof"/> operator to group converters and enable lazy-loading upon first use.  </param>
            <param name="name"> A custom label for the converter or `null` if none is set, particularly used for Transform function disambiguates (i.e. identical In/Out parameters) </param>
            <param name="dependencyInjection">Whether the declaring converter class is instantiated via dependency Injection.</param>
        </member>
        <member name="P:Core.TypeCast.ConverterAttribute.Id">
            <summary>
            Gets a unique ID of the converter based on an underlying <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterAttribute.BaseType">
            <summary>
            Gets or sets the base type i.e. the declaring type (see: <see cref="P:System.Type.DeclaringType"/> containing or declaring the converter-functions.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterAttribute.DependencInjection">
            <summary>
            Gets or sets a value indicating whether dependency injection should be used during instancing of a new custom converter />.
            </summary>
        </member>
        <member name="P:Core.TypeCast.ConverterAttribute.LoadOnDemand">
            <summary>
            Gets a value indicating whether the <see cref="T:Core.TypeCast.Converter`2"/> Converter is supposed to be initialized merely by declaring the <see cref="T:Core.TypeCast.ConverterAttribute"/>
            </summary>
            <example> **Example:**  A Converter `StringToDNA ` is allowed to be initialized by the <see cref="T:Core.TypeCast.ConverterAttribute"/> 
            <code>```cs
                [Converter(loadOnDemand: true, nameSpace: nameof(Program.NameSpace))]
                internal class StringToDNA {
                {   
                    ...
                    public StringToDNA(IConverterCollection collection, bool storeRNA = false){ ... }
                    ...
                }
                ...
            ```</code>
            </example>
        </member>
        <member name="P:Core.TypeCast.ConverterAttribute.NameSpace">
            <summary>
            Gets the <see cref="P:System.Type.Namespace"/> or an empty string if no <see cref="P:Core.TypeCast.ConverterAttribute.NameSpace"/> is set.
            </summary>
            <example> **Example:**  A Converter `StringToDNA` is added to the collection namespace of the main `Program` class
            <code>
            ```cs
                [Converter(nameSpace: nameof(Program.NameSpace))]
                internal class StringToDNA {
                {   
                    ...
                    public StringToDNA(IConverterCollection collection,  storeRNA = false){ ... }
                    ...
                }
                ...
            ```</code>
            </example>
            <remarks>The namespace is used for filtering and grouping <see cref="N:Core.TypeCast.Converters"/></remarks>
        </member>
        <member name="P:Core.TypeCast.ConverterAttribute.Name">
            <summary>
            Gets a custom label for the converter or `null` if none is set 
            </summary>
            <remarks>Use for filtering.</remarks>
        </member>
        <member name="T:Core.Extensions.TypeInfoExtension">
            <summary>
            The  <see cref="T:System.Reflection.TypeInfo"/> extension.
            </summary>
        </member>
        <member name="M:Core.Extensions.TypeInfoExtension.GetConstructorsByParameterType(System.Reflection.TypeInfo,System.Type)">
            <summary>
            Get a an <seealso cref="!:IEnumerable&lt;System.Reflection.ConstructorInfo&gt;"/> of all constructors that match the argument <paramref name="parameterType"/>
            </summary>
            <param name="type">The own instance of the <see cref="T:System.Reflection.TypeInfo"/> which invokes the method. </param>
            <param name="parameterType">The required parameter type which has to be present in the constructor's parameter-list.</param>
            <returns>The <see cref="!:IEnumerable&lt;System.Reflection.ConstructorInfo&gt;"/> of <see cref="T:System.Reflection.ConstructorInfo"/> that match the criteria. </returns>
            <remarks>In most cases the criteria should be narrowed to return one potential <see cref="T:System.Reflection.ConstructorInfo"/>. </remarks>
        </member>
        <member name="M:Core.Extensions.TypeInfoExtension.GetConstructorByParameterTypes(System.Reflection.TypeInfo,System.Type[])">
            <summary>
            Get a a single <seealso cref="T:System.Reflection.ConstructorInfo"/> of the first constructors that match the argument <paramref name="parameterTypes"/> otherwise returns `null`
            </summary>
            <param name="type">The own instance of the <see cref="T:System.Reflection.TypeInfo"/> which invokes the method. </param>
            <param name="parameterTypes">The required parameter types which have to be present in the constructor's parameter-list.</param>
            <returns>The <see cref="T:System.Reflection.ConstructorInfo"/> of <see cref="T:System.Reflection.ConstructorInfo"/> that match the criteria. </returns>
            <remarks>Make sure the criteria are narrowed down to yield only one potential <see cref="T:System.Reflection.ConstructorInfo"/> to avoid errant disambiguates. </remarks>
        </member>
        <member name="M:Core.Extensions.TypeInfoExtension.IsDependencyInjectable(System.Reflection.TypeInfo,System.Type)">
            <summary>
            Yields true if a <see cref="!:class"/> or <see cref="!:struct"/> contain a constructor of a <see cref="T:System.Type"/> "<paramref name="interfaceType"/>"
            </summary>
            <param name="type">The own instance of the <see cref="T:System.Reflection.TypeInfo"/> which invokes the method. </param>
            <param name="interfaceType">The parameter argument <see cref="T:System.Type"/> which should be, but does not strictly has to be, an <see cref="!:interface"/>.</param>
            <returns>Returns true if <paramref name="type"/> has a constructor that can be used for Dependency Injection of <paramref name="interfaceType"/>.</returns>
            <remarks>The method-extension can be used to dynamically detect if a constructor is present for Dependency Injection via <paramref name="interfaceType"/>. </remarks>
        </member>
        <member name="M:Core.Extensions.TypeInfoExtension.IsInvokableWithParameters(System.Reflection.TypeInfo,System.Type,System.Type[])">
            <summary>
            Checks if a delegate <see cref="T:System.Type"/> matches the <see cref="P:System.Reflection.MethodInfo.ReturnParameter"/> and argument types in order and <see cref="T:System.Type"/>
            </summary>
            <param name="method">A delegate Type from which a MethodInfo is looked up to compare argument-types with the arguments provided</param>
            <param name="returnParameter">The `return parameter` to compare with the return-parameter of the method</param>
            <param name="argumentParameters">The parameters to compare in sequence and <see cref="T:System.Type"/> to the method's arguments</param>
            <returns>Return `true` if the parameter all match in sequence order and type</returns>
        </member>
        <member name="M:Core.Extensions.TypeInfoExtension.GetDefault(System.Reflection.TypeInfo)">
            <summary>
            Yields null for any reference <see cref="T:System.Type"/> or the default value of any value type <see cref="P:System.Reflection.TypeInfo.IsValueType"/> that has a parameterless constructor 
            </summary>
            <param name="type">The own instance of the <see cref="T:System.Reflection.TypeInfo"/> which invokes the static extension method. </param>
            <returns>Returns an object that is either null or containing the default value of the underlying value type.</returns>
        </member>
        <member name="M:Core.Extensions.TypeInfoExtension.GetReturnParameterType(System.Reflection.TypeInfo,System.Type)">
            <summary>
            Gets the Return Parameter <see cref="T:System.Type"/> of any Delegate type instance else returns  `null`
            </summary>
            <param name="type">The own instance of the <see cref="T:System.Reflection.TypeInfo"/> which invokes the static extension method. </param>
            <param name="defaultType">A default <see cref="T:System.Type"/> to be passed out in case of no parameter being present. 
            If the input type does not inherit from <see cref="T:System.Delegate"/> the result will still be `null`</param>
            <returns>Returns an <see cref="T:System.Type"/> instance of the delegate's return-parameter or null `null`.</returns>
        </member>
        <member name="M:Core.Extensions.TypeInfoExtension.IsSameOrSimilar``1(System.Reflection.TypeInfo,System.Nullable{System.Boolean})">
            <summary>
            Compares the nature between two types and returns a <see cref="T:Core.Extensions.TypeMatch"/> <see cref="T:System.Enum"/> value.
            If the parameter <paramref name="checkIsSame"/> is set to <see cref="!:true"/>, a <see cref="T:Core.Extensions.TypeMatch"/> value of <see cref="F:Core.Extensions.TypeMatch.Same"/> is returned if the Types match else <see cref="F:Core.Extensions.TypeMatch.None"/> is returned. 
            If the parameter <paramref name="checkIsSame"/> is set to <see cref="!:false"/>,  the <see cref="P:System.Type.Namespace"/> of the input <paramref name="self"/> and output type <typeparamref name="TOut"/> is compared. 
            If the parameter <paramref name="checkIsSame"/> is set to <see cref="!:null"/> all values of <see cref="T:Core.Extensions.TypeMatch"/> are possible as return value.
            </summary>
            <typeparam name="TOut">The Target / To- <see cref="T:System.Type" /> to which to <see cref="!:Converter&lt;TIn,TOut&gt;.Convert(object,object)" /></typeparam>
            <param name="self">The current instance holding the boxed value to convert from</param>
            <param name="checkIsSame"> If the parameter is set to <see cref="!:true"/>, <see cref="F:Core.Extensions.TypeMatch.None"/> means they types do not match. 
            If set to <see cref="!:false"/>, the result <see cref="F:Core.Extensions.TypeMatch.None"/> means the types are not similar. 
            If set to <see cref="!:null"/>,  the result <see cref="F:Core.Extensions.TypeMatch.None"/> means that the types do not share a relationship.</param>
            <returns>Returns the nature of the compared types as an <see cref="T:Core.Extensions.TypeMatch"/> <see cref="T:System.Enum"/> value.</returns>
        </member>
        <member name="T:Core.Extensions.TypeMatch">
            <summary>
            An enumerating of values containing a rough 2bit classification of relationship between two types
            </summary>
            <remarks>The enumeration relates to the type change classification of Cast, Convert and Transform</remarks>
        </member>
        <member name="F:Core.Extensions.TypeMatch.None">
            <summary>
            Unknown or no relationship between the types
            </summary>
        </member>
        <member name="F:Core.Extensions.TypeMatch.Same">
            <summary>
            Identical or same relationship between the types
            </summary>
        </member>
        <member name="F:Core.Extensions.TypeMatch.Similar">
            <summary>
            Similar or same base relationship between the types
            </summary>
        </member>
    </members>
</doc>
